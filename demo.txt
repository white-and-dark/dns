client.c文件如下：
#include<stdio.h>
#include<sys/types.h>
#include<string.h>
#include<unistd.h>
#include<netinet/in.h>
#include<sys/socket.h>
#include<unistd.h>
#include<stdlib.h>
#include<netinet/in.h>
#include<arpa/inet.h>
#include<stdint.h>

#include "DNS.h"
#define DNS_MAX_LENGTH 1023
#define A 1
#define MX 0x000F 
#define CNAME 5
#define IN 1
void my_strcpy(dns_query *b, char *a);
unsigned char* convertDomainName(char *name);
unsigned int head2buf(char *o, dns_header *header);
unsigned int query2buf(char *o, dns_query *query);
unsigned int getHeader(char *q, dns_header * header); 
unsigned int getQuery(char *q, dns_query *query);
unsigned int getRRs(char *q, dns_rr *rRecord);
//int getPieceLen(char *ptr);



//创建TCP服务器实现服务器和客户端的通信
int main()
{

//创建socket套接字
	int clientfd=0;
	clientfd=socket(AF_INET,SOCK_STREAM,0);
	if(clientfd<0)
	{
		perror("socket failed");
		return -1;
	}
	//printf("socket ok!\n");
//客户端可以不绑定IP地址和端口号，系统会随机分配
//客户端连接服务器
	int ret=0;
	int addrlen=0;
	struct sockaddr_in seraddr={0};
	seraddr.sin_family=AF_INET;
	seraddr.sin_port=htons(53);
	seraddr.sin_addr.s_addr=inet_addr("127.0.0.2");
	addrlen=sizeof(seraddr);
	ret=connect(clientfd,(struct sockaddr *)&seraddr,addrlen);
	if(ret<0)
	{
		perror("connect failed");
		close(clientfd);
		return -1;
	}
	printf("Connected with server successfully!\n");
//调用send向服务器发送消息


	
		unsigned char queryInfo[127];
		unsigned char qType[127];
		unsigned char* convertQueryInfo; 
		char bufOut[DNS_MAX_LENGTH]; memset(bufOut, 0, DNS_MAX_LENGTH);
		char bufIn[DNS_MAX_LENGTH]; memset(bufIn, 0, DNS_MAX_LENGTH);
		char *o = bufOut + 2; //开头留两字节显示大小便于抓包 
		char *i = bufIn + 2; //将接收到的前两字节删掉 
		unsigned short qClass;
		unsigned short offset = 0;
		unsigned short *offsetptr; 
		int rev=0; 
		/*
		 *进入发收状态 
		 */
	   while(1)
        {
		/*
		 *清空原有buff，初始化 
		 */	 
        memset(bufOut, 0, DNS_MAX_LENGTH);
        memset(bufIn, 0, DNS_MAX_LENGTH);
		o = bufOut + 2; //开头留两字节显示大小便于抓包 
		i = bufIn + 2; //将接收到的前两字节删掉 
        offset = 0;
        rev=0; 
        
        /*
		 *结构体内存 
		 */ 
		dns_query *query = (dns_query *)malloc(sizeof(dns_query));initQuery(query);
		dns_header *head = (dns_header *)malloc(sizeof(dns_header));initHead(head);
		dns_rr *rRecord = (dns_rr *)malloc(sizeof(dns_rr));initRR(rRecord);
		//得到的的结构体 
		dns_query *recvQuery = (dns_query *)malloc(sizeof(dns_query));initQuery(recvQuery);
		dns_header *recvHead = (dns_header *)malloc(sizeof(dns_header));initHead(recvHead);
		dns_rr *recvRecord = (dns_rr *)malloc(sizeof(dns_rr));initRR(recvRecord);
		//MX第二次查询ip
		dns_query *mxQuery = (dns_query *)malloc(sizeof(dns_query));initQuery(mxQuery);
		dns_header *mxHead = (dns_header *)malloc(sizeof(dns_header));initHead(mxHead);
		dns_rr *mxRecord = (dns_rr *)malloc(sizeof(dns_rr));initRR(mxRecord);
		/*
		 *输入域名 
		 */ 
		do{
			printf("Please input the domain name and query type:\n");
			scanf("%s %s", queryInfo, qType);
			fflush(stdin);
		}while(!strcmp(qType, "A") && !strcmp(qType, "MX") && !strcmp(qType, "0")
			&& !strcmp(qType, "CNAME"));
		
		printf("------------------QUERY------------------\n");
		printf("The Query Domain Name is: %s\n", queryInfo);
		printf("The Query Type is: %s\n", qType);
		printf("Now Start the Query Process\n");
		printf("-----------------------------------------\n");
		head->id = htons(head->id = 1);
		head->tag = htons(head->tag = 4);
		head->queryNum = htons(head->queryNum = 1);
		head->answerNum = 0;
		head->authorNum = 0;
		head->addNum = 0;
		o += head2buf(o, head);
		my_strcpy(query, queryInfo);
		
		
		//输入验证类型 
		if(!strcmp(qType, "A")) query->qtype = A_TYPE;
		else if (!strcmp(qType, "MX")) query->qtype = MX_TYPE;
		else if (!strcmp(qType, "CNAME")) query->qtype = CNAME_TYPE;
		else if (!strcmp(qType, "0")) query->qtype = 0; 
		
		query->qclass = IN;
		
		o += query2buf(o,query); 
		offset = o - bufOut - 2; //开头留两字节显示大小便于抓包 
		offsetptr = &offset;
		uint16_t temp = htons(offset); 
		memcpy(bufOut, &temp, sizeof(short)); //将DNS包长度写在前两字节 
		

		/*
		 *退出接口 
		 */ 
        if(query->qtype==0)   break;
        
	    /*
		 *发送接口 
		 */ 
		if(send(clientfd, bufOut, offset+2, 0)<0){
       	  perror("send");
          return 2;
       }else{ 
    	printf("Send Query to Local Server\n");
    	} 

    	
	    /*
	     *接收接口 
	     */
	    memset(bufIn,0,sizeof(bufIn));
      	rev=recv(clientfd,bufIn,sizeof(bufIn),0);
	    // if(rev>0)
     	// {
        //     int i=0;
	    // 	for(i=0;i<rev;i++){
		// 	printf("%d ",bufIn[i]);
		//     }
		// printf("\n");
     	// }
	
		//以下为接收答案并解析的代码
		printf("------------------ANSWER------------------\n");
		i += getHeader(i, recvHead); 
		if(recvHead->tag == 33152){  //成功找到并返回结果
		printf("Find the Answers\n");
			i += getQuery(i, recvQuery); 
			recvRecord->name = recvQuery->name; 
			recvRecord->type = recvQuery->qtype;
			recvRecord->rclass = recvQuery->qclass;
			
			i += 6; //压缩指针那两个字节和后面的2个type，共6字节  
			//在这里送去解析的只有rr的后几个值 
			i += getRRs(i, recvRecord);
			if(recvQuery->qtype == MX){
				mxRecord->name = (char*)malloc((strlen(recvRecord->rdata)+1)*sizeof(char));
				strcpy(mxRecord->name, recvRecord->rdata);
				mxRecord->type = A_TYPE;
				mxRecord->rclass = 1;
				i += getRRs(i, mxRecord);
			}

			printf("Query Name: %s\n", recvRecord->name); 
			if(recvRecord->type == A_TYPE){
				printf("Query Type: A\n"); 
				printf("Query Class: IN\n"); 
				printf("TTL: %d\n", recvRecord->ttl);
				printf("IP Addr: %s\n", recvRecord->rdata);
			}
			else if(recvRecord->type == CNAME_TYPE){
				printf("Query Type: CNAME\n");
				printf("Query Class: IN\n"); 
				printf("TTL: %d\n", recvRecord->ttl);
				printf("Another Domain Name Addr: %s\n", recvRecord->rdata);
			} 
			else if(recvRecord->type == MX_TYPE){
				printf("Query Type: MX\n");
				printf("Query Class: IN\n"); 
				printf("TTL: %d\n", recvRecord->ttl);
				printf("Mail Server Domain Name: %s\n", recvRecord->rdata);
				printf("Mail Server IP Address: %s\n", mxRecord->rdata);
			} 
		}else{ //嘛也没找着
			i += getQuery(i, recvQuery); 
			printf("Sorry, we didn't found anything\n");
			printf("Please try again later!\n");
		}
		printf("----------------ANSWER END----------------\n");
		
       }
    printf("Quit with Safety\n");
	close(clientfd);
	return 0;

}

void my_strcpy(dns_query *b, char* a){
	int len = strlen(a)+1;
	//printf("length: %d\n", len);
	b->name = (char*)malloc(len*sizeof(char));
	memcpy(b->name, a, len);
	//printf("look: %s, %s\n", b->name, a);
}

unsigned int head2buf(char *o, dns_header *head){
	memcpy(o, head, sizeof(dns_header));
	int p=0;
	// while(p<=sizeof(dns_header)){
	// printf("buff2: %hu\n", o[p]);
	// p++;
	// }
	return sizeof(dns_header);
}

unsigned int query2buf(char *o, dns_query *query){
	char* ini = o; //for initial
	uint8_t count = 0;
	int i = 0;
	int j = 1; //转换后计数 
	int tempts = 0;
	o++; //先往后移动一位 
	while(1){
		//printf("get: %c\n", query->name[i]);
		if(query->name[i] == '.'){
				memcpy(o-count-1, &count, sizeof(char));
				//printf("Count: %d\n", count);
				count = 0;
				o++; i++;
				tempts = 1;
				
		}
		else if(query->name[i] == '\0'){
			memcpy(o, &(query->name[i]), sizeof(char));
			memcpy(o-count-1, &count, sizeof(char));
			count = 0;
			break;
		}
		else{
			memcpy(o, &(query->name[i]), sizeof(char));
			o++;
			i++;
			count++; 
		}
	}
	o++;
	int len = o - ini; //计算出名字的长度 
	uint16_t temp = htons(query->qtype);
	memcpy(o, &temp, sizeof(short));
	temp = htons(query->qclass);
	o+=sizeof(short);
	memcpy(o, &temp, sizeof(short));
	o+=sizeof(short);
//	int p=0;
//	while(p<=100){
//	printf("buff1: %hu\n", o[p]);
//	p++;
//	}
	return len+2*sizeof(short);
}


// //截取第一个字符串的长度 
// int getPieceLen(char *ptr){
// 	int i=0;
// 	while(1){
// 		if(ptr[i]==' '||ptr[i]=='\n'||ptr[i]=='\0')
// 			break;
// 		else i++;
// 	}
// 	return i+1;
// }

unsigned char* convertDomainName(char *name){
	//printf("%s\n", name);
	unsigned char *converted;
	int i = 0;
	int j = 1; //转换后计数 
	int count = 0;
	int tempts = 0;
	while(1){
		//printf("char %c\n", name[i]);
		if(name[i] == '.'){
			if(tempts == 0){
			converted[0] = count + '0';
			//printf("Count: %d\n", count);
			count = 0;
			i++; j++;
			tempts = 1;
			}
			else{
			converted[j-count-1] = count + '0';
			//printf("Count: %d\n", count);
			count = 0;
			i++; j++;
			}
			
		}
		else if(name[i] == '\0'){
			converted[j] = name[i];
			converted[j-count-1] = count + '0';
			break;
		}
		else{
			converted[j] = name[i];
			j++;
			i++;
			count++; 
		}
	}
	//("Converted: %s\n", converted); 
	return converted;
}

//下面这两个函数和localServer中的一样，可以考虑打包进.h 
unsigned int getHeader(char *q, dns_header *header){
	
	header->id = ntohs(*(uint16_t*) (q));
	header->tag = ntohs(*(uint16_t*) (q+2));
	header->queryNum = ntohs(*(uint16_t*) (q+4));
	//printf("queryName: %d\n", header->id);
	header->answerNum = ntohs(*(uint16_t*) (q+6));
	header->authorNum = ntohs(*(uint16_t*) (q+8));
	header->addNum = ntohs(*(uint16_t*) (q+10));
	
	return sizeof(dns_header);
}

//下面这三个函数和localServer中的一样，可以考虑打包进.h 
unsigned int getQuery(char *q, dns_query *query){
	char domainName[100];
	memset(domainName, 0, 100);
	char *d = domainName;
	//printf("d: %s\n", d);
	uint8_t count = 0;
	int i = 0; 
	//count = ntohs(*(uint8_t*)(q));
	//完成报文中数字加域名形式至点分值的转换 
	while(1){
		if(*q!='\0'){
			count = *(uint8_t*)(q);
			//("count:%d\n", count);
			q++;
			while(count){
				//printf("i: %d\n", i);
				//printf("char1:%c\n", *q);
				memcpy(&(domainName[i]), q, sizeof(char));
				//printf("domain name i: %c\n", domainName[i]);
				count--; q++; i++;
			}
			domainName[i] = '.'; //加点 
			i++;
		}
		else{
			domainName[i-1] = '\0'; //标注结束 
			q++; 
			break;
		}
	}
	// printf("i: %d\n", i);  
	// printf("Converted domain name: %s\n", domainName);
	// printf("length: %d\n", i);
	query->name = (char*)malloc(i*sizeof(char));
	memcpy(query->name, domainName, i); //此时的i便为转换后变长字符串的长度了，经过了循环遍历 
	// printf("Query name: %s\n", query->name);
	
	query->qtype = ntohs(*(uint16_t*) (q));
	query->qclass = ntohs(*(uint16_t*) (q+2));
	// printf("Query Type: %d\n", query->qtype);
	// printf("Query Class: %d\n", query->qclass);
	return i+4+1; //补一个1的原因是网络的域名形式和转换后的差一位 
}

unsigned int getRRs(char *q, dns_rr *rRecord){
	uint32_t ipAddr;
	rRecord->ttl = ntohl(*(uint32_t*)(q)); //这里是ntohl，32bit数字的转化 
	char str[INET_ADDRSTRLEN];
	struct in_addr addr;
	//printf("Query Answer TTL: %d\n", rRecord->ttl);
	q+=sizeof(rRecord->ttl);
	rRecord->data_len = ntohs(*(uint16_t*)(q));
	//printf("Data Length: %d\n", rRecord->data_len);
	q+=sizeof(rRecord->data_len);
	//rRecord->rdata = (char*)malloc((rRecord->data_len)*sizeof(char));
	//printf("hello\n");
	if(rRecord->type == MX_TYPE){
		q += 2; //将Preferencre的长度空出去
	}
	
	if(rRecord->type == A_TYPE){
		ipAddr = *(uint32_t*)(q);
		//printf("Query Answer TTL: %d\n", rRecord->ttl);
		memcpy(&addr, &ipAddr, 4);
		char *ptr = inet_ntop(AF_INET, &addr, str, sizeof(str)); //转化为十进制点分值的IP地址
		//printf("Query Answer IP: %s\n", ptr);
		rRecord->rdata = (char*)malloc((strlen(ptr)+1)*sizeof(char));
		strcpy(rRecord->rdata,ptr);
		return 4 + 2 + rRecord->data_len;
	}
	else if(rRecord->type == CNAME_TYPE){
		char domainName[100];
	memset(domainName, 0, 100);
	char *d = domainName;
	//printf("d: %s\n", d);
	uint8_t count = 0;
	int i = 0; 
	//count = ntohs(*(uint8_t*)(q));
	//完成报文中数字加域名形式至点分值的转换 
	while(1){
		if(*q!='\0'){
			count = *(uint8_t*)(q);
			//printf("count:%d\n", count);
			q++;
			while(count){
				//printf("i: %d\n", i);
				//printf("char1:%c\n", *q);
				memcpy(&(domainName[i]), q, sizeof(char));
				//printf("domain name i: %c\n", domainName[i]);
				count--; q++; i++;
			}
			domainName[i] = '.'; //加点 
			i++;
		}
		else{
			domainName[i-1] = '\0'; //标注结束 
			q++; 
			break;
		}
	}
	// printf("i: %d\n", i);  
	// printf("Converted domain name: %s\n", domainName);
	// printf("length: %d\n", i);
	rRecord->rdata = (char*)malloc(i*sizeof(char));
	memcpy(rRecord->rdata, domainName, i); //此时的i便为转换后变长字符串的长度了，经过了循环遍历 
	// printf("Query name: %s\n", rRecord->rdata);
	// 	printf("The CNAME is: %s\n", rRecord->rdata);
		return 4 + 2 + rRecord->data_len +1;
	}
	else if(rRecord->type == MX_TYPE){
		int firstlen = rRecord->data_len - 5;
		char domainName[100];
		memset(domainName, 0, 100);
		char *d = domainName;
		//printf("d: %s\n", d);
		uint8_t count = 0;
		int i = 0; 
	//count = ntohs(*(uint8_t*)(q));
	//完成报文中数字加域名形式至点分值的转换 
		while(1){
		if(*q!='\0'){
			count = *(uint8_t*)(q);
			//printf("count:%d\n", count);
			q++;
			while(count){
				//printf("i: %d\n", i);
				//printf("char1:%c\n", *q);
				memcpy(&(domainName[i]), q, sizeof(char));
				//printf("domain name i: %c\n", domainName[i]);
				count--; q++; i++;
			}
			domainName[i] = '.'; //加点 
			i++;
			domainName[i] = '\0';
			i++;
			break;
		}
	}
	//printf("i: %d\n", i);  
	//printf("Converted domain name: %s\n", domainName);
	//printf("length: %d\n", i);
	strcpy(domainName, strcat(domainName, rRecord->name)); //由于压缩了指针，对两字符串进行拼接
	//printf("Converted domain name: %s\n", domainName);
	int totalen = strlen(rRecord->name) + i; //拼接后总长度
	rRecord->rdata = (char*)malloc(totalen*sizeof(char));
	memcpy(rRecord->rdata, domainName, totalen); 
	//printf("Query name: %s\n", rRecord->rdata);
		//printf("The CNAME is: %s\n", rRecord->rdata);
		return 12+rRecord->data_len;
	}
	
}

cnus.c文件如下：
#include<stdio.h>
#include<sys/types.h>
#include<string.h>
#include<unistd.h>
#include<netinet/in.h>
#include<sys/socket.h>
#include<unistd.h>
#include<stdlib.h>
#include<netinet/in.h>
#include<arpa/inet.h>
#include<stdint.h>
#include "DNS.h"
#define LINE     10
#define DNS_MAX_LENGTH 1023
int isequal(char *str1, char* str2);
void init_sockaddr_in(char* ip, int port, struct sockaddr_in* addr);
unsigned int getHeader(char *q, dns_header *header);
unsigned int getQuery(char *q, dns_query *query);
void splitTwoDomainName(char *domainName, char *splitName);
unsigned int head2buf(char *o, dns_header *header);
unsigned int query2buf(char *o, dns_query *query);
unsigned int getRRs(char *q, dns_rr *rRecord);
unsigned int rr2buf(char *o, dns_rr* rr); 

int main(){
	int sockup;
	struct sockaddr_in localAddr;
	struct sockaddr_in upAddr;
	struct sockaddr_in downAddr;
	unsigned int upAddrLen;
	char upInBuffer[DNS_MAX_LENGTH];
	char upOutBuffer[DNS_MAX_LENGTH];
	char splitName[128]; //把二级域名存进来 
	char ipAddr[100];
	dns_query *recvQuery = (dns_query *)malloc(sizeof(dns_query));initQuery(recvQuery);
	dns_header *recvHead = (dns_header *)malloc(sizeof(dns_header));initHead(recvHead);
	//回应的结构体 
	dns_query *resQuery = (dns_query *)malloc(sizeof(dns_query));initQuery(resQuery);
	dns_header *resHead = (dns_header *)malloc(sizeof(dns_header));initHead(resHead);
	dns_rr *resRecord = (dns_rr *)malloc(sizeof(dns_rr));initRR(resRecord);
	unsigned short port=53;
	int recvMsgSize;
	int outMsgSize; 
	char *i;
	char *o;
	
	
	if((sockup=socket(PF_INET,SOCK_DGRAM,0))<0)  printf("socket() failed\n");
	
	init_sockaddr_in("127.0.0.5", 53, &localAddr);
	if((bind (sockup,(struct sockaddr*)&localAddr,sizeof(localAddr)))<0){
		printf("bind() failed\n");
	} 
	while(1){
	upAddrLen=sizeof(upAddr);
	//receive
	if((recvMsgSize=recvfrom(sockup,upInBuffer,DNS_MAX_LENGTH,0,(struct sockaddr*)&upAddr,&upAddrLen))<0){
		printf("recvfrom() failed\n");
	}
	printf("Handling client %s\n",inet_ntoa(upAddr.sin_addr));
	
    //解析localServer传过来的数据 
	i = upInBuffer;
	i += getHeader(i, recvHead);
	i += getQuery(i, recvQuery); 	
	//printf("The domain name is: %s\n", recvQuery->name);
	//printf("The First Class Name is: %s\n", splitOneDomainName(recvQuery->name));
	splitTwoDomainName(recvQuery->name, splitName);
	
	
	//解析部分至上就结束了，以下为回应部分
	resHead->id =htons(recvHead->id);
	resHead->tag =htons(0x8000);
	resHead->queryNum =htons(recvHead->queryNum);
	resHead->answerNum = htons(1); //这里不一定是1，若没查到怎么办？？ 
	resHead->authorNum = 0;
	resHead->addNum = 0;
	resQuery = recvQuery;
	resRecord->name=recvQuery->name;
    resRecord->rclass=recvQuery->qclass;
	resRecord->type=A_TYPE;
	resRecord->ttl = (uint32_t)86400;
	resRecord->data_len = 4;
	
	//printf("compare:  %s\n",splitName);
    int tf=isequal(splitName,"com");
    //printf("bbbbbb: %d\n",tf);
    tf=isequal(splitName,"org");
    //printf("basafds: %d\n",tf);
	
	/*
	 *返回查询结果 
	 */
	if(isequal(splitName,"edu.cn")){
		//在结构体里把rdata赋值为 "127.0.0.6" ,在head里把anwernum赋值为 1，flag为8000 
	   // printf("hello, in edu.cn!\n");
	    strcpy(ipAddr, "127.0.0.6");
	    //printf("hello,%s\n", ipAddr);
	    char *p = ipAddr;
	    int len = strlen(ipAddr)+1;
	    resRecord->rdata=(char*)malloc(len*sizeof(char));
	    //printf("hello, in org!\n");
	    memcpy(resRecord->rdata,p,len);
	    //printf("resRecordDataL %s\n", resRecord->rdata);
	    //printf("hello, out edu.cn!\n");
		o = upOutBuffer; 
	 	o += head2buf(o, resHead);
	 	o += query2buf(o,resQuery); 
	 	o += rr2buf(o,resRecord);

	}
	else if (isequal(splitName,"gov.us")){
		//在结构体里把rdata赋值为 "127.0.0.7" ,在head里把anwernum赋值为 1，flag 为8000 
		//printf("hello, in gov!\n");
		strcpy(ipAddr, "127.0.0.7");
		char *p = ipAddr;
	    int len = strlen(ipAddr)+1;
	    resRecord->rdata=(char*)malloc(len*sizeof(char));
	    memcpy(resRecord->rdata,p,len);
	    //printf("resRecordDataL %s\n", resRecord->rdata);
	    //printf("hello, out gov!\n");
		o = upOutBuffer; 
	 	o += head2buf(o, resHead);
	 	o += query2buf(o,resQuery); 
	 	o += rr2buf(o,resRecord);
		
	}
	else{
		//在结构体里把rdata赋值为空，head answernum赋值为1 flag 为8183 
		resHead->answerNum = 0;
		//printf("in else\n");
		strcpy(ipAddr, "255.255.255.255");
		resHead->tag =htons(0x8183);
		char *p = ipAddr;
	    int len = strlen(ipAddr)+1;
	    resRecord->rdata=(char*)malloc(len*sizeof(char));
	    memcpy(resRecord->rdata,p,len);
	    //printf("resRecordDataL %s\n", resRecord->rdata);
	    //printf("out else\n");
		//rdata无数值，anwernum为0
		//查询失败 
		o = upOutBuffer; 
	 	o += head2buf(o, resHead);
		o += query2buf(o,resQuery); 
	}
	
	/*
	 *压缩返回 
	 */
	
	
	//send
	outMsgSize=o - upOutBuffer +1;
	//printf("length:%d \n",outMsgSize);
	if(sendto(sockup,upOutBuffer,outMsgSize,0,(struct sockaddr*)&upAddr,sizeof(upAddr))!=outMsgSize){
		printf("sendto() problem!\n");
	}
	
	}	
}
void splitTwoDomainName(char *domainName, char *splitName){
	int i = strlen(domainName)-1; //免去\0的影响 
	//printf("domainName: %s\n", domainName);
	int j = 0;
	int k = 0;
	int countdot=0;
	char invertName[100];
	char splitOneName[100];
	memset(invertName, 0, 100);
	memset(splitOneName, 0, 100);
	while(1){
		if(domainName[i]!='.'){
			//printf("d: %c\n", domainName[i]);
			invertName[j] = domainName[i];
			//printf("s: %c\n", invertName[j]);
			i--;j++; 
		}
		else if(countdot==0){
			//printf("d: %c\n", domainName[i]);
			invertName[j] = domainName[i];
			//printf("s: %c\n", invertName[j]);
			i--;j++; 
			countdot++;
		}
		else break;
	}
	invertName[j] = '\0';
	//printf("splitOneInvert: %s\n", invertName);
	i = strlen(invertName)-1;
	while(1){
		if(k < strlen(invertName)){
			//printf("s: %c\n", invertName[i]);
			splitName[k] = invertName[i];
			i--; k++;
		}else break;
		
	}
	splitName[k] = '\0';
	//printf("splitTwo: %s\n", splitName);
}
void init_sockaddr_in(char* ip, int port, struct sockaddr_in* addr){
    addr->sin_family = AF_INET;
    addr->sin_port = htons(port);
    addr->sin_addr.s_addr=inet_addr(ip);
    memset(addr->sin_zero, 0, sizeof(addr->sin_zero));
}
 int isequal(char *str1, char* str2)
{
    if (strlen(str1)!=strlen(str2))
     return 0;
     int i=0;
    for (i = 0; str1[i]!='\0'; i++){
        if (str1[i]!=str2[i])
        return 0;
     }
   return 1;
  }
  
unsigned int head2buf(char *o, dns_header *head){
	memcpy(o, head, sizeof(dns_header));
	//////////////////////////////////////////////没转主机字节序！！！！！ 
	return sizeof(dns_header);
}

unsigned int query2buf(char *o, dns_query *query){
	char* ini = o; //for initial
	uint8_t count = 0;
	int i = 0;
	int j = 1; //转换后计数 
	int tempts = 0;
	o++; //先往后移动一位 
	while(1){
		//printf("get: %c\n", query->name[i]);
		if(query->name[i] == '.'){
				memcpy(o-count-1, &count, sizeof(char));
				//printf("Count: %d\n", count);
				count = 0;
				o++; i++;
				tempts = 1;
				
		}
		else if(query->name[i] == '\0'){
			memcpy(o, &(query->name[i]), sizeof(char));
			memcpy(o-count-1, &count, sizeof(char));
			count = 0;
			break;
		}
		else{
			memcpy(o, &(query->name[i]), sizeof(char));
			o++;
			i++;
			count++; 
		}
	}
	o++;
	int len = o - ini; //计算出名字的长度
	//printf("length: %d\n", len); 
	uint16_t temp = htons(query->qtype);
	memcpy(o, &temp, sizeof(short));
	temp = htons(query->qclass);
	o+=sizeof(short);
	memcpy(o, &temp, sizeof(short));
	o+=sizeof(short);
//	int p=0;
//	while(p<=100){
//	printf("buff1: %hu\n", o[p]);
//	p++;
//	}
	printf("length22: %d\n",  len+2*sizeof(short)); 
	return len+2*sizeof(short);
}

unsigned int rr2buf(char *o, dns_rr* rr) {
	int i = 0;
	uint16_t temp;
	uint32_t temp32;
	temp =  htons(49164); //这里指代1100000000001100，DNS报文中压缩指针的操作
	memcpy(o, &temp, sizeof(short)); 
//	printf("rr2leng: %d\n", strlen(rr->name));
//	memcpy(o,rr->name,strlen(rr->name)+1);
//	while(1){
//		printf("ccc: %c\n", o[i]);
//		i++;
//		if(i == 5) break;
//	}
//	printf("rrName: %s\n", o);
	o+=2;
	
	temp=htons(rr->type);
	memcpy(o, &temp, sizeof(short));
	//printf("rrType: %d\n", rr->type);
	o+=2;
	
	temp=htons(rr->rclass);
	memcpy(o, &temp, sizeof(short));
	o+=2;
	
	temp32=htonl(rr->ttl); //这里是htonl 32位数字的主机字节序转化 
	//printf("ttlconvert: %d\n", temp32);
	memcpy(o, &temp32, (2*sizeof(short)));
	o+=4;
	
	temp=htons(rr->data_len);
	memcpy(o, &temp, sizeof(short));
	o+=2;
	
	uint32_t  ipAddr = inet_addr(rr->rdata);
	memcpy(o, &ipAddr,rr->data_len); //将字符串转化为网络字节序的4bytes数据 
	//printf("rrDate: %s\n", o);
	o+=rr->data_len; //也就是要移动4位 
	return 11+strlen(rr->name)+(rr->data_len);
}

unsigned int getHeader(char *q, dns_header *header){
	// int i = 0;
	// while(1){
	// 	if(i<100){
	// 		printf("headerIn: %d\n", q[i]);i++;
	// 	}
		
	// 	else break;
	// }
	
	header->id = ntohs(*(uint16_t*) (q));
	header->tag = ntohs(*(uint16_t*) (q+2));
	header->queryNum = ntohs(*(uint16_t*) (q+4));
	//printf("queryName: %d\n", header->id);
	header->answerNum = ntohs(*(uint16_t*) (q+6));
	header->authorNum = ntohs(*(uint16_t*) (q+8));
	header->addNum = ntohs(*(uint16_t*) (q+10));
	
	return sizeof(dns_header);
}

unsigned int getQuery(char *q, dns_query *query){
	char domainName[100];
	memset(domainName, 0, 100);
	char *d = domainName;
	//printf("d: %s\n", d);
	uint8_t count = 0;
	int i = 0; 
	//count = ntohs(*(uint8_t*)(q));
	//完成报文中数字加域名形式至点分值的转换 
	while(1){
		if(*q!='\0'){
			count = *(uint8_t*)(q);
			printf("count:%d\n", count);
			q++;
			while(count){
				//printf("i: %d\n", i);
				//printf("char1:%c\n", *q);
				memcpy(&(domainName[i]), q, sizeof(char));
				//printf("domain name i: %c\n", domainName[i]);
				count--; q++; i++;
			}
			domainName[i] = '.'; //加点 
			i++;
		}
		else{
			domainName[i-1] = '\0'; //标注结束 
			q++; 
			break;
		}
	}
	// printf("i: %d\n", i);  
	// printf("Converted domain name: %s\n", domainName);
	// printf("length: %d\n", i);
	query->name = (char*)malloc(i*sizeof(char));
	memcpy(query->name, domainName, i); //此时的i便为转换后变长字符串的长度了，经过了循环遍历 
	//printf("Query name: %s\n", query->name);
	
	query->qtype = ntohs(*(uint16_t*) (q));
	query->qclass = ntohs(*(uint16_t*) (q+2));
	// printf("Query Type: %d\n", query->qtype);
	// printf("Query Class: %d\n", query->qclass);
	return i+4+1; //补一个1的原因是网络的域名形式和转换后的差一位 
}

comorgA.txt文件如下：
wyx.microsoft.com 86400 IN A 192.168.3.1
yzy.ietf.org 86400 IN A 192.168.3.2
mail.shiyan.microsoft.com 86400 IN A 192.168.3.5
mail.dns.ietf.org 86400 IN A 192.168.3.7
comorg.c文件如下：
#include<stdio.h>
#include<sys/types.h>
#include<string.h>
#include<unistd.h>
#include<netinet/in.h>
#include<sys/socket.h>
#include<unistd.h>
#include<stdlib.h>
#include<netinet/in.h>
#include<arpa/inet.h>
#include<stdint.h>
#include "DNS.h"
#define LINE     10
#define DNS_MAX_LENGTH 1023
unsigned int getHeader(char *q, dns_header *header);
unsigned int getQuery(char *q, dns_query *query);
unsigned int getRRs(char *q, dns_rr *rRecord);
int isequal(char *str1, char* str2);
unsigned int rr2buf(char *o, dns_rr* rr);
unsigned int query2buf(char *o, dns_query *query);
unsigned int head2buf(char *o, dns_header *header);
unsigned int add2buf(char *o, dns_rr* rr, dns_query* query);


void init_sockaddr_in(char* ip, int port, struct sockaddr_in* addr);

int main(){
	int state=0;  //查到没有 
	int sockup;
	struct sockaddr_in localAddr;
	struct sockaddr_in upAddr;
	struct sockaddr_in downAddr;
	unsigned int upAddrLen;
	char upInBuffer[DNS_MAX_LENGTH];
	char upOutBuffer[DNS_MAX_LENGTH];
	unsigned short port=53;
	int recvMsgSize;
	int outMsgSize; 
	char ipAddr[100];
	//不需要分割名字，因为已经是最底层服务器，拿文件查询即可 
	
	//接受的结构体 
	dns_query *recvQuery = (dns_query *)malloc(sizeof(dns_query));initQuery(recvQuery);
	dns_header *recvHead = (dns_header *)malloc(sizeof(dns_header));initHead(recvHead);
	dns_rr *recvrRecord = (dns_rr *)malloc(sizeof(dns_rr));initRR(recvrRecord);  
	//回应的结构体 
	dns_query *resQuery = (dns_query *)malloc(sizeof(dns_query));initQuery(resQuery);
	dns_header *resHead = (dns_header *)malloc(sizeof(dns_header));initHead(resHead);
	dns_rr *resRecord = (dns_rr *)malloc(sizeof(dns_rr));initRR(resRecord);
	//MX第二次查询ip
	dns_query *mxQuery = (dns_query *)malloc(sizeof(dns_query));initQuery(mxQuery);
	dns_header *mxHead = (dns_header *)malloc(sizeof(dns_header));initHead(mxHead);
	dns_rr *mxRecord = (dns_rr *)malloc(sizeof(dns_rr));initRR(mxRecord);
	
	
	if((sockup=socket(PF_INET,SOCK_DGRAM,0))<0)  printf("socket() failed\n");
	
	init_sockaddr_in("127.0.0.4", 53, &localAddr);
	if((bind (sockup,(struct sockaddr*)&localAddr,sizeof(localAddr)))<0){
		printf("bind() failed\n");
	} 
	while(1){
	state=0;
	upAddrLen=sizeof(upAddr);
	//receive
	if((recvMsgSize=recvfrom(sockup,upInBuffer,DNS_MAX_LENGTH,0,(struct sockaddr*)&upAddr,&upAddrLen))<0){
		printf("recvfrom() failed\n");
	}
	printf("Handling client %s\n",inet_ntoa(upAddr.sin_addr));
	
	//解析
	char *i = upInBuffer;
	i += getHeader(i, recvHead);
	i += getQuery(i, recvQuery); 	
	printf("The domain name is: %s\n", recvQuery->name);
	
	//以下为回应的部分
	resHead->id =htons(recvHead->id);
	resHead->tag =htons(0x8000);
	resHead->queryNum =htons(recvHead->queryNum);
	resHead->answerNum = htons(1); //这里不一定是1，若没查到怎么办？？ 
	resHead->authorNum = 0;
	resHead->addNum = 0;
	resQuery = recvQuery;
	resRecord->name=recvQuery->name;
    resRecord->rclass=recvQuery->qclass;
	resRecord->type=recvQuery->qtype;
	resRecord->ttl = (uint32_t)86400;
	resRecord->data_len = 4;
	
	//printf("recvQuery->qType: %d\n",recvQuery->qtype);
	/*
	 *返回查询结果 
	 */
	 if(recvQuery->qtype==A_TYPE) {
	   freopen("comorgA.txt", "r", stdin);
	   char file_name[255],file_ttl[255],file_class[255],file_type[255],file_ip[255];
	    while(~scanf("%s%s%s%s%s", file_name, file_ttl, file_class,file_type,file_ip)){
	    	if(isequal(recvQuery->name,file_name)){
	    		printf("file_name: %s\n",file_name);
	    		printf("file_name length: %d\n",strlen(file_name));
	    		printf("file_ttl: %s\n",file_ttl);
	    		printf("file_class； %s\n",file_class);
	    		printf("file_type: %s\n",file_type);
	    		printf("file_ip: %s\n",file_ip);
				//不确定你从文件里读出来的是什么样子的，含不含空格，长度下面有可能不对

				resRecord->name = (char*)malloc((strlen(file_name)+1)*sizeof(char));
				strcpy(resRecord->name, file_name);
				resRecord->ttl = (uint32_t)(atoi(file_ttl));
				resRecord->rdata = (char*)malloc((strlen(file_ip)+1)*sizeof(char));
				strcpy(resRecord->rdata, file_ip);
				resHead->answerNum = htons(1);
				resRecord->data_len=strlen(resRecord->rdata)+1;
				resHead->tag = htons(0x8180);

	    		//printf("recv->Query: %s\n",recvQuery->name);
	    		//在结构体里把rdata赋值为 file_ip ,在head里把anwernum赋值为1，flag为8180 
	    		state=1;   //表明查到 
	    		break;
			}
		}   
	}
	else if(recvQuery->qtype==CNAME_TYPE){
		freopen("comorgC.txt", "r", stdin);
	   char file_name[255],file_ttl[255],file_class[255],file_type[255],file_addr[255];
	    while(~scanf("%s%s%s%s%s", file_name, file_ttl, file_class,file_type,file_addr)){
	    	if(isequal(recvQuery->name,file_name)){
	    		printf("file_name: %s\n",file_name);
	    		printf("file_name length: %d\n",strlen(file_name));
	    		printf("file_ttl: %s\n",file_ttl);
	    		printf("file_class； %s\n",file_class);
	    		printf("file_type: %s\n",file_type);
	    		printf("file_ip: %s\n",file_addr);
				//不确定你从文件里读出来的是什么样子的，含不含空格，长度下面有可能不对

				resRecord->name = (char*)malloc((strlen(file_name)+1)*sizeof(char));
				strcpy(resRecord->name, file_name);
				resRecord->ttl = (uint32_t)(atoi(file_ttl));
				resRecord->rdata = (char*)malloc((strlen(file_addr)+1)*sizeof(char));
				strcpy(resRecord->rdata, file_addr);
				resHead->answerNum = htons(1);
				resRecord->data_len=strlen(resRecord->rdata)+1;
				resHead->tag = htons(0x8180);

	    		//printf("recv->Query: %s\n",recvQuery->name);
	    		//在结构体里把rdata赋值为 file_ip ,在head里把anwernum赋值为1，flag为8180 
	    		state=1;   //表明查到 
	    		break;
			}
		}   
	}
	else if(recvQuery->qtype==MX_TYPE){
		//printf("in file M\n");
		freopen("comorgM.txt", "r", stdin);
		//printf("flag1\n"); 
	   char file_name[255],file_ttl[255],file_class[255],file_type[255],file_addr[255];
	    while(~scanf("%s%s%s%s%s", file_name, file_ttl, file_class,file_type,file_addr)){
	    	//printf("flag2\n");
	    	if(isequal(recvQuery->name,file_name)){
	    		printf("file_name: %s\n",file_name);
	    		printf("file_name length: %d\n",strlen(file_name));
	    		printf("file_ttl: %s\n",file_ttl);
	    		printf("file_class； %s\n",file_class);
	    		printf("file_type: %s\n",file_type);
	    		printf("file_addr: %s\n",file_addr);
				//不确定你从文件里读出来的是什么样子的，含不含空格，长度下面有可能不对

				resRecord->name = (char*)malloc((strlen(file_name)+1)*sizeof(char));
				strcpy(resRecord->name, file_name);
				resRecord->ttl = (uint32_t)(atoi(file_ttl));
				resRecord->rdata = (char*)malloc((strlen(file_addr)+1)*sizeof(char));
				strcpy(resRecord->rdata, file_addr);
				resHead->answerNum = htons(1);
				//这里用现在的域名减去查询的名字长度再+2(pre..)+2(压缩指针)
		        resRecord->data_len = strlen(resRecord->rdata)-strlen(recvQuery->name) + 4;
				resHead->tag = htons(0x8180);

	    		//printf("recv->Query: %s\n",recvQuery->name);
	    		//在结构体里把rdata赋值为 file_ip ,在head里把anwernum赋值为1，flag为8180 
	    		state=1;   //表明查到 
	    		break;
			}
		} 
		if(state==1){
		mxQuery->name = (char*)malloc((strlen(resRecord->rdata)+1)*sizeof(char));
		strcpy(mxQuery->name, resRecord->rdata);
		//printf("mxQueryName: %s\n", mxQuery->name);
		mxQuery->qclass = recvQuery->qclass;
		mxQuery->qtype = A_TYPE; //这里要用上一次的结果A方式查询一下
		freopen("comorgA.txt", "r", stdin);
	    char file_ip[255];
	    while(~scanf("%s%s%s%s%s", file_name, file_ttl, file_class,file_type,file_ip)){
	    	if(isequal(mxQuery->name,file_name)){
	    		printf("file_name: %s\n",file_name);
	    		printf("file_name length: %d\n",strlen(file_name));
	    		printf("file_ttl: %s\n",file_ttl);
	    		printf("file_class； %s\n",file_class);
	    		printf("file_type: %s\n",file_type);
	    		printf("file_ip: %s\n",file_ip);
				//不确定你从文件里读出来的是什么样子的，含不含空格，长度下面有可能不对	
		    	mxRecord->name = (char*)malloc((strlen(file_name)+1)*sizeof(char));
				strcpy(mxRecord->name, file_name);
				mxRecord->ttl = (uint32_t)(atoi(file_ttl));
				mxRecord->rdata = (char*)malloc((strlen(file_addr)+1)*sizeof(char));
				strcpy(mxRecord->rdata, file_ip);
				mxRecord->data_len=4;
				mxRecord->type=A_TYPE; 
	            mxRecord->rclass=recvQuery->qclass;
                resHead->addNum = htons(1); 

	    		//printf("recv->Query: %s\n",recvQuery->name);
	    		//在结构体里把rdata赋值为 file_ip ,在head里把anwernum赋值为1，flag为8180 
	    		state=1;   //表明查到 
	    		break;
			}
		}
	  }
	 }	  
	 //printf("state %d\n",state);
	char* o=upOutBuffer;
	//查不到的情况
	if(state==0){
		//printf("1\n");
		resHead->tag =htons(0x8183);
		//printf("2\n");
		resHead->answerNum = 0;
		//printf("3\n");
		o = upOutBuffer; 
		//printf("4\n");
	 	o += head2buf(o, resHead);
	 	//printf("5\n");
	 	o += query2buf(o,resQuery);
		//在结构体里把rdata赋值为找不到 ,在head里把anwernum赋值为 1，flag为8183 
	}else{
		o = upOutBuffer; 
	 	o += head2buf(o, resHead);
	 	o += query2buf(o,resQuery); 
	 	o += rr2buf(o,resRecord);
	 	if(recvQuery->qtype == MX_TYPE)
	 	o+=add2buf(o, mxRecord, recvQuery);
	}


	//统一返回
	//把upOutBuffer赋值 
	outMsgSize = o - upOutBuffer + 1;
	//printf("length:%d \n",outMsgSize);
	if(sendto(sockup,upOutBuffer,outMsgSize,0,(struct sockaddr*)&upAddr,sizeof(upAddr))!=outMsgSize){
		printf("sendto() problem!\n");
	}
	
	}	

}
unsigned int head2buf(char *o, dns_header *head){
	memcpy(o, head, sizeof(dns_header));
	//////////////////////////////////////////////没转主机字节序！！！！！ 
	return sizeof(dns_header);
}

void init_sockaddr_in(char* ip, int port, struct sockaddr_in* addr){
    addr->sin_family = AF_INET;
    addr->sin_port = htons(port);
    addr->sin_addr.s_addr=inet_addr(ip);
    memset(addr->sin_zero, 0, sizeof(addr->sin_zero));
}

unsigned int getHeader(char *q, dns_header *header){
	// int i = 0;
	// while(1){
	// 	if(i<100){
	// 		printf("headerIn: %d\n", q[i]);i++;
	// 	}
		
	// 	else break;
	// }
	
	header->id = ntohs(*(uint16_t*) (q));
	header->tag = ntohs(*(uint16_t*) (q+2));
	header->queryNum = ntohs(*(uint16_t*) (q+4));
	//printf("queryName: %d\n", header->id);
	header->answerNum = ntohs(*(uint16_t*) (q+6));
	header->authorNum = ntohs(*(uint16_t*) (q+8));
	header->addNum = ntohs(*(uint16_t*) (q+10));
	
	return sizeof(dns_header);
}

//下面这三个函数和localServer中的一样，可以考虑打包进.h 
unsigned int getQuery(char *q, dns_query *query){
	char domainName[100];
	memset(domainName, 0, 100);
	char *d = domainName;
	//printf("d: %s\n", d);
	uint8_t count = 0;
	int i = 0; 
	//count = ntohs(*(uint8_t*)(q));
	//完成报文中数字加域名形式至点分值的转换 
	while(1){
		if(*q!='\0'){
			count = *(uint8_t*)(q);
			//printf("count:%d\n", count);
			q++;
			while(count){
				//printf("i: %d\n", i);
				//printf("char1:%c\n", *q);
				memcpy(&(domainName[i]), q, sizeof(char));
				//printf("domain name i: %c\n", domainName[i]);
				count--; q++; i++;
			}
			domainName[i] = '.'; //加点 
			i++;
		}
		else{
			domainName[i-1] = '\0'; //标注结束 
			q++; 
			break;
		}
	}
	// printf("i: %d\n", i);  
	// printf("Converted domain name: %s\n", domainName);
	// printf("length: %d\n", i);
	query->name = (char*)malloc(i*sizeof(char));
	memcpy(query->name, domainName, i); //此时的i便为转换后变长字符串的长度了，经过了循环遍历 
	//printf("Query name: %s\n", query->name);
	
	query->qtype = ntohs(*(uint16_t*) (q));
	query->qclass = ntohs(*(uint16_t*) (q+2));
	//printf("Query Type: %d\n", query->qtype);
	//printf("Query Class: %d\n", query->qclass);
	return i+4+1; //补一个1的原因是网络的域名形式和转换后的差一位 
}

unsigned int getRRs(char *q, dns_rr *rRecord){
	uint32_t ipAddr;
	rRecord->ttl = ntohl(*(uint32_t*)(q)); //这里是ntohl，32bit数字的转化 
	char str[INET_ADDRSTRLEN];
	struct in_addr addr;
	//printf("Query Answer TTL: %d\n", rRecord->ttl);
	q+=sizeof(rRecord->ttl);
	rRecord->data_len = ntohs(*(uint16_t*)(q));
	//printf("Data Length: %d\n", rRecord->data_len);
	q+=sizeof(rRecord->data_len);
	rRecord->rdata = (char*)malloc((rRecord->data_len)*sizeof(char));
	//printf("hello\n");
	if(rRecord->type == MX_TYPE){
		q += 2; //将Preferencre的长度空出去
	}
	
	if(rRecord->type == A_TYPE){
		ipAddr = *(uint32_t*)(q);
		//printf("Query Answer TTL: %d\n", rRecord->ttl);
		memcpy(&addr, &ipAddr, 4);
		char *ptr = inet_ntop(AF_INET, &addr, str, sizeof(str)); //转化为十进制点分值的IP地址
		//printf("Query Answer IP: %s\n", ptr);
		return 4 + 2 + rRecord->data_len;
	}
	else if(rRecord->type == CNAME_TYPE){
		char domainName[100];
	memset(domainName, 0, 100);
	char *d = domainName;
	//printf("d: %s\n", d);
	uint8_t count = 0;
	int i = 0; 
	//count = ntohs(*(uint8_t*)(q));
	//完成报文中数字加域名形式至点分值的转换 
	while(1){
		if(*q!='\0'){
			count = *(uint8_t*)(q);
			//printf("count:%d\n", count);
			q++;
			while(count){
				//printf("i: %d\n", i);
				//printf("char1:%c\n", *q);
				memcpy(&(domainName[i]), q, sizeof(char));
				//printf("domain name i: %c\n", domainName[i]);
				count--; q++; i++;
			}
			domainName[i] = '.'; //加点 
			i++;
		}
		else{
			domainName[i-1] = '\0'; //标注结束 
			q++; 
			break;
		}
	}
	// printf("i: %d\n", i);  
	// printf("Converted domain name: %s\n", domainName);
	// printf("length: %d\n", i);
	rRecord->rdata = (char*)malloc(i*sizeof(char));
	memcpy(rRecord->rdata, domainName, i); //此时的i便为转换后变长字符串的长度了，经过了循环遍历 
	// printf("Query name: %s\n", rRecord->rdata);
	// 	printf("The CNAME is: %s\n", rRecord->rdata);
		return 4 + 2 + rRecord->data_len +1;
	}
	else if(rRecord->type == MX_TYPE){
		int firstlen = rRecord->data_len - 5;
		char domainName[100];
		memset(domainName, 0, 100);
		char *d = domainName;
		//printf("d: %s\n", d);
		uint8_t count = 0;
		int i = 0; 
	//count = ntohs(*(uint8_t*)(q));
	//完成报文中数字加域名形式至点分值的转换 
		while(1){
		if(*q!='\0'){
			count = *(uint8_t*)(q);
			//printf("count:%d\n", count);
			q++;
			while(count){
				// printf("i: %d\n", i);
				// printf("char1:%c\n", *q);
				memcpy(&(domainName[i]), q, sizeof(char));
				//printf("domain name i: %c\n", domainName[i]);
				count--; q++; i++;
			}
			domainName[i] = '.'; //加点 
			i++;
			domainName[i] = '\0';
			i++;
			break;
		}
	}
	// printf("i: %d\n", i);  
	// printf("Converted domain name: %s\n", domainName);
	// printf("length: %d\n", i);
	strcpy(domainName, strcat(domainName, rRecord->name)); //由于压缩了指针，对两字符串进行拼接
	//printf("Converted domain name: %s\n", domainName);
	int totalen = strlen(rRecord->name) + i; //拼接后总长度
	rRecord->rdata = (char*)malloc(totalen*sizeof(char));
	memcpy(rRecord->rdata, domainName, totalen); 
	//printf("Query name: %s\n", rRecord->rdata);
		//printf("The CNAME is: %s\n", rRecord->rdata);
		return 12+rRecord->data_len;
	}
	
}

unsigned int query2buf(char *o, dns_query *query){
	char* ini = o; //for initial
	uint8_t count = 0;
	int i = 0;
	int j = 1; //转换后计数 
	int tempts = 0;
	o++; //先往后移动一位 
	while(1){
		//printf("get: %c\n", query->name[i]);
		if(query->name[i] == '.'){
				memcpy(o-count-1, &count, sizeof(char));
				//printf("Count: %d\n", count);
				count = 0;
				o++; i++;
				tempts = 1;
				
		}
		else if(query->name[i] == '\0'){
			memcpy(o, &(query->name[i]), sizeof(char));
			memcpy(o-count-1, &count, sizeof(char));
			count = 0;
			break;
		}
		else{
			memcpy(o, &(query->name[i]), sizeof(char));
			o++;
			i++;
			count++; 
		}
	}
	o++;
	int len = o - ini; //计算出名字的长度
	//printf("length: %d\n", len); 
	uint16_t temp = htons(query->qtype);
	memcpy(o, &temp, sizeof(short));
	temp = htons(query->qclass);
	o+=sizeof(short);
	memcpy(o, &temp, sizeof(short));
	o+=sizeof(short);
//	int p=0;
//	while(p<=100){
//	printf("buff1: %hu\n", o[p]);
//	p++;
//	}
	//printf("length22: %d\n",  len+2*sizeof(short)); 
	return len+2*sizeof(short);
}

unsigned int rr2buf(char *o, dns_rr* rr) {
	int i = 0;
	uint16_t temp;
	uint32_t temp32;
	temp =  htons(49164); //这里指代1100000000001100，DNS报文中压缩指针的操作
	memcpy(o, &temp, sizeof(short)); 
	
//	printf("rr2leng: %d\n", strlen(rr->name));
//	memcpy(o,rr->name,strlen(rr->name)+1);
//	while(1){
//		printf("ccc: %c\n", o[i]);
//		i++;
//		if(i == 5) break;
//	}
//	printf("rrName: %s\n", o);
	o+=2;
	//printf("flag3\n");
	temp=htons(rr->type);
	memcpy(o, &temp, sizeof(short));
	printf("rrType: %d\n", rr->type);
	o+=2;
	//printf("flag3\n");
	temp=htons(rr->rclass);
	memcpy(o, &temp, sizeof(short));
	o+=2;
	//printf("flag3\n");
	temp32=htonl(rr->ttl); //这里是htonl 32位数字的主机字节序转化 
	printf("ttlconvert: %d\n", temp32);
	memcpy(o, &temp32, (2*sizeof(short)));
	o+=4;
	//printf("flag3\n");
	temp=htons(rr->data_len);
	memcpy(o, &temp, sizeof(short));
	o+=2;
	//printf("flag3\n");
	//这里指preference，MX里面要多两个字节哦
	if(rr->type == MX_TYPE){
		temp=htons(1);
		memcpy(o, &temp, sizeof(short));
		o+=2;
	}
	
	if(rr->type == A_TYPE){
		uint32_t  ipAddr = inet_addr(rr->rdata);
		memcpy(o, &ipAddr,rr->data_len); //将字符串转化为网络字节序的4bytes数据 
		//printf("rrDate: %s\n", o);
		o+=rr->data_len; //也就是要移动4位 
		return 16;
	}
	else if(rr->type == CNAME_TYPE){
		char* ini = o; //for initial
	uint8_t count = 0;
	int i = 0;
	int j = 1; //转换后计数 
	int tempts = 0;
	o++; //先往后移动一位 
	while(1){
		//printf("get: %c\n", rr->rdata[i]);
		if(rr->rdata[i] == '.'){
				memcpy(o-count-1, &count, sizeof(char));
				//printf("Count: %d\n", count);
				count = 0;
				o++; i++;
				tempts = 1;
				
		}
		else if(rr->rdata[i] == '\0'){
			memcpy(o, &(rr->rdata[i]), sizeof(char));
			memcpy(o-count-1, &count, sizeof(char));
			count = 0;
			break;
		}
		else{
			memcpy(o, &(rr->rdata[i]), sizeof(char));
			o++;
			i++;
			count++; 
		}
	}
		return 12 + rr->data_len + 1;
	}
	else if(rr->type == MX_TYPE){ //MX的情况
		char* ini = o; //for initial
	uint8_t count = 0;
	int i = 0;
	int j = 1; //转换后计数 
	int tempts = 0;
	o++; //先往后移动一位 
	while(1){
		//printf("get: %c\n", rr->rdata[i]);
		if(rr->rdata[i] == '.'){
				memcpy(o-count-1, &count, sizeof(char));
				//printf("Count: %d\n", count);
				count = 0;
				o++; i++;
				tempts = 1;
				break;
				
		}
		else if(rr->rdata[i] == '\0'){
			memcpy(o, &(rr->rdata[i]), sizeof(char));
			memcpy(o-count-1, &count, sizeof(char));
			count = 0;
			break;
		}
		else{
			memcpy(o, &(rr->rdata[i]), sizeof(char));
			o++;
			i++;
			count++; 
		}
	}
	o--;
	//printf("i=%d\n", i);
	temp =  htons(49164); //这里指代1100000000001100，DNS报文中压缩指针的操作
	memcpy(o, &temp, sizeof(short)); 
	return 16+i;
	}
	
	
}

 int isequal(char *str1, char* str2)
{
    if (strlen(str1)!=strlen(str2))
     return 0;
     int i=0;
    for (i = 0; str1[i]!='\0'; i++){
        if (str1[i]!=str2[i])
        return 0;
     }
   return 1;
  }
  
  //用于MX的ip查询，放到addtion里面
unsigned int add2buf(char *o, dns_rr* rr, dns_query* query) {
	//printf("add2buf rrdata: %s\n", rr->rdata);
	//printf("datalength: %d\n", strlen(rr->rdata));
	int i = 0;
	uint16_t temp;
	uint32_t temp32;
	temp =  htons(49152+12+strlen(query->name)+2+4+14); //这里指代1100000000001100，DNS报文中压缩指针的操作
	memcpy(o, &temp, sizeof(short)); 
//	printf("rr2leng: %d\n", strlen(rr->name));
//	memcpy(o,rr->name,strlen(rr->name)+1);
//	while(1){
//		printf("ccc: %c\n", o[i]);
//		i++;
//		if(i == 5) break;
//	}
//	printf("rrName: %s\n", o);
	o+=2;
	temp=htons(rr->type);
	memcpy(o, &temp, sizeof(short));
	//printf("rrType: %d\n", rr->type);
	o+=2;

	temp=htons(rr->rclass);
	memcpy(o, &temp, sizeof(short));
	o+=2;

	temp32=htonl(rr->ttl); //这里是htonl 32位数字的主机字节序转化 
	//printf("ttlconvert: %d\n", temp32);
	memcpy(o, &temp32, (2*sizeof(short)));
	o+=4;

	temp=htons(rr->data_len);
	memcpy(o, &temp, sizeof(short));
	o+=2;

	
	
	uint32_t  ipAddr = inet_addr(rr->rdata);
	memcpy(o, &ipAddr, rr->data_len); //将字符串转化为网络字节序的4bytes数据 
	//printf("rrDate: %d\n", ipAddr);
	o+=rr->data_len; //也就是要移动4位 
	return 16;
}
comorgC.txt文件如下：
wyx.microsoft.com 86400 IN CNAME wyx.dns.com
yzy.ietf.org 86400 IN CNAME yzy.dns.com

comorgM.txt文件如下：
shiyan.microsoft.com 86400 IN MX mail.shiyan.microsoft.com
dns.ietf.org 86400 IN MX mail.dns.ietf.org


DNS.h文件如下：
#ifndef DNS_H_
#define DNS_H_
#define DNSMAXLEN 526
#define QR 32768
#define NAME_TO_ADDR 0
#define ADDR_TO_NAME 2048
#define SERV_STAT 4096
#define AA 1024
#define TC 512
#define RD 256
#define RA 128
#define SUCCESS 0
#define FORMAT_ERR 1
#define SERV_ERR 2
#define NOT_EXIST 3
#define FORMAT_NOT_SUPPORT 4
#define POLICY 5
#define A_TYPE 1
#define NS_TYPE 2
#define CNAME_TYPE 5
#define MX_TYPE 15
#define PTR_TYPE 12 

//DNSHeader 的数据结构
struct DNS_Header{
	unsigned short id;
	unsigned short tag;
	unsigned short queryNum;
	unsigned short answerNum;
	unsigned short authorNum;
	unsigned short addNum;
};

typedef struct DNS_Header dns_header;

//DNSQuery 数据结构 
struct DNS_Query{
	unsigned char* name;
	unsigned short qtype;
	unsigned short qclass;
};

typedef struct DNS_Query dns_query;

//DNSResponseMessage 数据结构 
struct DNS_RR{
	unsigned char *name;
	unsigned short type;
	unsigned short rclass;
	unsigned int ttl;
	unsigned short data_len;
	unsigned char *rdata;
};

typedef struct DNS_RR dns_rr;

//初始化Heading 
void initHead(dns_header *head){
	head->id=0;
	head->tag=0;
	head->queryNum=0;
	head->answerNum=0;
	head->authorNum=0;
	head->addNum=0;
}

//初始化Query 
void initQuery(dns_query *query){
	//printf("Hello\n"); 
	if(query->name!=NULL){
		printf("hi\n");
		free(query->name);
		query->name=NULL;
	}
	//printf("end\n"); 
	query->qtype=0;
	query->qclass=0;
}

//初始刷RR 
void initRR(dns_rr *rr){
	if(rr->name!=NULL){
		free(rr->name);
		rr->name=NULL;
	}
	if(rr->rdata!=NULL){
		free(rr->rdata);
		rr->rdata=NULL;
	}
	rr->type=0;
	rr->rclass=0;
	rr->ttl=0;
	rr->data_len=0;
}

#endif

eduA.txt文件如下：
yzy.edu.cn 86400 IN A 192.168.88.12
wyx.edu.cn 86400 IN A 192.168.12.11
mail.aaa.edu.cn 86400 IN A 192.132.11.2
mail.ddd.edu.cn 86400 IN A 192.111.11.1

edu.c文件如下：

#include<stdio.h>
#include<sys/types.h>
#include<string.h>
#include<unistd.h>
#include<netinet/in.h>
#include<sys/socket.h>
#include<unistd.h>
#include<stdlib.h>
#include<netinet/in.h>
#include<arpa/inet.h>
#include<stdint.h>
#include "DNS.h"
#define LINE     10
#define DNS_MAX_LENGTH 1023

unsigned int getHeader(char *q, dns_header *header);
unsigned int getQuery(char *q, dns_query *query);
unsigned int getRRs(char *q, dns_rr *rRecord);
int isequal(char *str1, char* str2);
unsigned int rr2buf(char *o, dns_rr* rr);
unsigned int query2buf(char *o, dns_query *query);
unsigned int head2buf(char *o, dns_header *header);
unsigned int add2buf(char *o, dns_rr* rr, dns_query* query);
void init_sockaddr_in(char* ip, int port, struct sockaddr_in* addr);
int main(){
	int state=0;  //查到没有 
	int sockup;
	struct sockaddr_in localAddr;
	struct sockaddr_in upAddr;
	struct sockaddr_in downAddr;
	unsigned int upAddrLen;
	char upInBuffer[DNS_MAX_LENGTH];
	char upOutBuffer[DNS_MAX_LENGTH];
	unsigned short port=53;
	int recvMsgSize;
	int outMsgSize; 
	char ipAddr[100];
	//不需要分割名字，因为已经是最底层服务器，拿文件查询即可 
	
	//接受的结构体 
	dns_query *recvQuery = (dns_query *)malloc(sizeof(dns_query));initQuery(recvQuery);
	dns_header *recvHead = (dns_header *)malloc(sizeof(dns_header));initHead(recvHead);
	dns_rr *recvrRecord = (dns_rr *)malloc(sizeof(dns_rr));initRR(recvrRecord); 
	//回应的结构体 
	dns_query *resQuery = (dns_query *)malloc(sizeof(dns_query));initQuery(resQuery);
	dns_header *resHead = (dns_header *)malloc(sizeof(dns_header));initHead(resHead);
	dns_rr *resRecord = (dns_rr *)malloc(sizeof(dns_rr));initRR(resRecord); 
	//MX第二次查询ip
	dns_query *mxQuery = (dns_query *)malloc(sizeof(dns_query));initQuery(mxQuery);
	dns_header *mxHead = (dns_header *)malloc(sizeof(dns_header));initHead(mxHead);
	dns_rr *mxRecord = (dns_rr *)malloc(sizeof(dns_rr));initRR(mxRecord);
	
	
	if((sockup=socket(PF_INET,SOCK_DGRAM,0))<0)  printf("socket() failed\n");
	
	init_sockaddr_in("127.0.0.6", 53, &localAddr);
	if((bind (sockup,(struct sockaddr*)&localAddr,sizeof(localAddr)))<0){
		printf("bind() failed\n");
	} 
	while(1){
	state=0;
	upAddrLen=sizeof(upAddr);
	//receive
	if((recvMsgSize=recvfrom(sockup,upInBuffer,DNS_MAX_LENGTH,0,(struct sockaddr*)&upAddr,&upAddrLen))<0){
		printf("recvfrom() failed\n");
	}
	printf("Handling client %s\n",inet_ntoa(upAddr.sin_addr));
	
	//解析
	char *i = upInBuffer;
	i += getHeader(i, recvHead);
	i += getQuery(i, recvQuery); 	
	printf("The domain name is: %s\n", recvQuery->name);
	
	//以下为回应的部分
	resHead->id =htons(recvHead->id);
	resHead->tag =htons(0x8000);
	resHead->queryNum =htons(recvHead->queryNum);
	resHead->answerNum = htons(1); //这里不一定是1，若没查到怎么办？？ 
	resHead->authorNum = 0;
	resHead->addNum = 0;
	resQuery = recvQuery;
	resRecord->name=recvQuery->name;
    resRecord->rclass=recvQuery->qclass;
	resRecord->type=recvQuery->qtype;
	resRecord->ttl = (uint32_t)86400;
	resRecord->data_len = 4;
	/*
	 *返回查询结果 
	 */
	 if(recvQuery->qtype==A_TYPE){
	   freopen("eduA.txt", "r", stdin);
	   char file_name[255],file_ttl[255],file_class[255],file_type[255],file_ip[255];
	    while(~scanf("%s%s%s%s%s", file_name, file_ttl, file_class,file_type,file_ip)){
	    	if(isequal(recvQuery->name,file_name)){
	    		printf("file_name: %s\n",file_name);
	    		printf("file_ttl: %s\n",file_ttl);
	    		printf("file_class； %s\n",file_class);
	    		printf("file_type: %s\n",file_type);
	    		printf("file_ip: %s\n",file_ip);
	    		//在结构体里把rdata赋值为 file_ip ,在head里把anwernum赋值为1，flag为8180 
	    		resRecord->name = (char*)malloc((strlen(file_name)+1)*sizeof(char));
				strcpy(resRecord->name, file_name);
				resRecord->ttl = (uint32_t)(atoi(file_ttl));
				resRecord->rdata = (char*)malloc((strlen(file_ip)+1)*sizeof(char));
				strcpy(resRecord->rdata, file_ip);
				resRecord->data_len=strlen(resRecord->rdata)+1;
				resHead->answerNum = htons(1);
				resHead->tag = htons(0x8180);
	    		
	    		state=1;   //表明查到 
	    		break;
			}
		}   	    
     }
     else if(recvQuery->qtype==CNAME_TYPE){
     	freopen("eduC.txt", "r", stdin);
	   char file_name[255],file_ttl[255],file_class[255],file_type[255],file_addr[255];
	    while(~scanf("%s%s%s%s%s", file_name, file_ttl, file_class,file_type,file_addr)){
	    	if(isequal(recvQuery->name,file_name)){
	    		printf("file_name: %s\n",file_name);
	    		printf("file_ttl: %s\n",file_ttl);
	    		printf("file_class； %s\n",file_class);
	    		printf("file_type: %s\n",file_type);
	    		printf("file_ip: %s\n",file_addr);
	    		//在结构体里把rdata赋值为 file_ip ,在head里把anwernum赋值为1，flag为8180 
	    		resRecord->name = (char*)malloc((strlen(file_name)+1)*sizeof(char));
				strcpy(resRecord->name, file_name);
				resRecord->ttl = (uint32_t)(atoi(file_ttl));
				resRecord->rdata = (char*)malloc((strlen(file_addr)+1)*sizeof(char));
				strcpy(resRecord->rdata, file_addr);
				resRecord->data_len=strlen(resRecord->rdata)+1;
				resHead->answerNum = htons(1);
				resHead->tag = htons(0x8180);
	    		
	    		state=1;   //表明查到 
	    		break;
			}
		}   	    
	 }
	 	else if(recvQuery->qtype==MX_TYPE){
		printf("in file M\n");
		freopen("eduM.txt", "r", stdin);
		printf("flag1\n"); 
	   char file_name[255],file_ttl[255],file_class[255],file_type[255],file_addr[255];
	    while(~scanf("%s%s%s%s%s", file_name, file_ttl, file_class,file_type,file_addr)){
	    	printf("flag2\n");
	    	if(isequal(recvQuery->name,file_name)){
	    		printf("file_name: %s\n",file_name);
	    		printf("file_name length: %d\n",strlen(file_name));
	    		printf("file_ttl: %s\n",file_ttl);
	    		printf("file_class； %s\n",file_class);
	    		printf("file_type: %s\n",file_type);
	    		printf("file_addr: %s\n",file_addr);
				//不确定你从文件里读出来的是什么样子的，含不含空格，长度下面有可能不对

				resRecord->name = (char*)malloc((strlen(file_name)+1)*sizeof(char));
				strcpy(resRecord->name, file_name);
				resRecord->ttl = (uint32_t)(atoi(file_ttl));
				resRecord->rdata = (char*)malloc((strlen(file_addr)+1)*sizeof(char));
				strcpy(resRecord->rdata, file_addr);
				resHead->answerNum = htons(1);
				//这里用现在的域名减去查询的名字长度再+2(pre..)+2(压缩指针)
		        resRecord->data_len = strlen(resRecord->rdata)-strlen(recvQuery->name) + 4;
				resHead->tag = htons(0x8180);

	    		//printf("recv->Query: %s\n",recvQuery->name);
	    		//在结构体里把rdata赋值为 file_ip ,在head里把anwernum赋值为1，flag为8180 
	    		state=1;   //表明查到 
	    		break;
			}
		} 
		if(state==1){
		mxQuery->name = (char*)malloc((strlen(resRecord->rdata)+1)*sizeof(char));
		strcpy(mxQuery->name, resRecord->rdata);
		//printf("mxQueryName: %s\n", mxQuery->name);
		mxQuery->qclass = recvQuery->qclass;
		mxQuery->qtype = A_TYPE; //这里要用上一次的结果A方式查询一下
		freopen("eduA.txt", "r", stdin);
	    char file_ip[255];
	    while(~scanf("%s%s%s%s%s", file_name, file_ttl, file_class,file_type,file_ip)){
	    	if(isequal(mxQuery->name,file_name)){
	    		printf("file_name: %s\n",file_name);
	    		printf("file_name length: %d\n",strlen(file_name));
	    		printf("file_ttl: %s\n",file_ttl);
	    		printf("file_class； %s\n",file_class);
	    		printf("file_type: %s\n",file_type);
	    		printf("file_ip: %s\n",file_ip);
				//不确定你从文件里读出来的是什么样子的，含不含空格，长度下面有可能不对	
		    	mxRecord->name = (char*)malloc((strlen(file_name)+1)*sizeof(char));
				strcpy(mxRecord->name, file_name);
				mxRecord->ttl = (uint32_t)(atoi(file_ttl));
				mxRecord->rdata = (char*)malloc((strlen(file_addr)+1)*sizeof(char));
				strcpy(mxRecord->rdata, file_ip);
				mxRecord->data_len=4;
				mxRecord->type=A_TYPE; 
	            mxRecord->rclass=recvQuery->qclass;
                resHead->addNum = htons(1); 

	    		//printf("recv->Query: %s\n",recvQuery->name);
	    		//在结构体里把rdata赋值为 file_ip ,在head里把anwernum赋值为1，flag为8180 
	    		state=1;   //表明查到 
	    		break;
			}
		}
	  }
	 } 	  
	//printf("state %d\n",state);
	 char* o=upOutBuffer;
	if(state==0){
		//printf("1\n");
		resHead->tag =htons(0x8183);
		//printf("2\n");
		resHead->answerNum = 0;
		//printf("3\n");
		o = upOutBuffer; 
		//printf("4\n");
	 	o += head2buf(o, resHead);
	 	//printf("5\n");
	 	o += query2buf(o,resQuery);
		//在结构体里把rdata赋值为找不到 ,在head里把anwernum赋值为 1，flag为8183 
	}else{
		o = upOutBuffer; 
	 	o += head2buf(o, resHead);
	 	o += query2buf(o,resQuery); 
	 	o += rr2buf(o,resRecord);
	 	if(recvQuery->qtype == MX_TYPE)
	 	o+=add2buf(o, mxRecord, recvQuery);
	}


	//统一返回
	//把upOutBuffer赋值 
	outMsgSize = o - upOutBuffer + 1;
	//printf("length:%d \n",outMsgSize);
	if(sendto(sockup,upOutBuffer,outMsgSize,0,(struct sockaddr*)&upAddr,sizeof(upAddr))!=outMsgSize){
		printf("sendto() problem!\n");
	}
  }	
}	
unsigned int head2buf(char *o, dns_header *head){
	memcpy(o, head, sizeof(dns_header));
	//////////////////////////////////////////////没转主机字节序！！！！！ 
	return sizeof(dns_header);
}

void init_sockaddr_in(char* ip, int port, struct sockaddr_in* addr){
    addr->sin_family = AF_INET;
    addr->sin_port = htons(port);
    addr->sin_addr.s_addr=inet_addr(ip);
    memset(addr->sin_zero, 0, sizeof(addr->sin_zero));
}

unsigned int getHeader(char *q, dns_header *header){
	// int i = 0;
	// while(1){
	// 	if(i<100){
	// 		printf("headerIn: %d\n", q[i]);i++;
	// 	}
		
	// 	else break;
	// }
	
	header->id = ntohs(*(uint16_t*) (q));
	header->tag = ntohs(*(uint16_t*) (q+2));
	header->queryNum = ntohs(*(uint16_t*) (q+4));
	//printf("queryName: %d\n", header->id);
	header->answerNum = ntohs(*(uint16_t*) (q+6));
	header->authorNum = ntohs(*(uint16_t*) (q+8));
	header->addNum = ntohs(*(uint16_t*) (q+10));
	
	return sizeof(dns_header);
}

//下面这三个函数和localServer中的一样，可以考虑打包进.h 
unsigned int getQuery(char *q, dns_query *query){
	char domainName[100];
	memset(domainName, 0, 100);
	char *d = domainName;
	//printf("d: %s\n", d);
	uint8_t count = 0;
	int i = 0; 
	//count = ntohs(*(uint8_t*)(q));
	//完成报文中数字加域名形式至点分值的转换 
	while(1){
		if(*q!='\0'){
			count = *(uint8_t*)(q);
			//("count:%d\n", count);
			q++;
			while(count){
				// printf("i: %d\n", i);
				// printf("char1:%c\n", *q);
				memcpy(&(domainName[i]), q, sizeof(char));
				//printf("domain name i: %c\n", domainName[i]);
				count--; q++; i++;
			}
			domainName[i] = '.'; //加点 
			i++;
		}
		else{
			domainName[i-1] = '\0'; //标注结束 
			q++; 
			break;
		}
	}
	// printf("i: %d\n", i);  
	// printf("Converted domain name: %s\n", domainName);
	// printf("length: %d\n", i);
	query->name = (char*)malloc(i*sizeof(char));
	memcpy(query->name, domainName, i); //此时的i便为转换后变长字符串的长度了，经过了循环遍历 
	//printf("Query name: %s\n", query->name);
	
	query->qtype = ntohs(*(uint16_t*) (q));
	query->qclass = ntohs(*(uint16_t*) (q+2));
	////printf("Query Type: %d\n", query->qtype);
	//printf("Query Class: %d\n", query->qclass);
	return i+4+1; //补一个1的原因是网络的域名形式和转换后的差一位 
}

unsigned int getRRs(char *q, dns_rr *rRecord){
	uint32_t ipAddr;
	rRecord->ttl = ntohl(*(uint32_t*)(q)); //这里是ntohl，32bit数字的转化 
	char str[INET_ADDRSTRLEN];
	struct in_addr addr;
	//printf("Query Answer TTL: %d\n", rRecord->ttl);
	q+=sizeof(rRecord->ttl);
	rRecord->data_len = ntohs(*(uint16_t*)(q));
	//printf("Data Length: %d\n", rRecord->data_len);
	q+=sizeof(rRecord->data_len);
	//rRecord->rdata = (char*)malloc((rRecord->data_len)*sizeof(char));
	//printf("hello\n");
	
	
	if(rRecord->type = A_TYPE){
		ipAddr = *(uint32_t*)(q);
		//printf("Query Answer TTL: %d\n", rRecord->ttl);
		memcpy(&addr, &ipAddr, 4);
		char *ptr = inet_ntop(AF_INET, &addr, str, sizeof(str)); //转化为十进制点分值的IP地址
		//printf("Query Answer IP: %s\n", ptr);
		rRecord->rdata = (char*)malloc((strlen(ptr)+1)*sizeof(char));
		strcpy(rRecord->rdata,ptr);
		return 4 + 2 + rRecord->data_len;
	}
	else if(rRecord->type = CNAME_TYPE){
		strcpy(rRecord->rdata, q);
		//printf("The CNAME is: %s\n", rRecord->rdata);
		return 4 + 2 + rRecord->data_len;
	}
	
}


unsigned int query2buf(char *o, dns_query *query){
	char* ini = o; //for initial
	uint8_t count = 0;
	int i = 0;
	int j = 1; //转换后计数 
	int tempts = 0;
	o++; //先往后移动一位 
	while(1){
		//printf("get: %c\n", query->name[i]);
		if(query->name[i] == '.'){
				memcpy(o-count-1, &count, sizeof(char));
				//printf("Count: %d\n", count);
				count = 0;
				o++; i++;
				tempts = 1;
				
		}
		else if(query->name[i] == '\0'){
			memcpy(o, &(query->name[i]), sizeof(char));
			memcpy(o-count-1, &count, sizeof(char));
			count = 0;
			break;
		}
		else{
			memcpy(o, &(query->name[i]), sizeof(char));
			o++;
			i++;
			count++; 
		}
	}
	o++;
	int len = o - ini; //计算出名字的长度
	//printf("length: %d\n", len); 
	uint16_t temp = htons(query->qtype);
	memcpy(o, &temp, sizeof(short));
	temp = htons(query->qclass);
	o+=sizeof(short);
	memcpy(o, &temp, sizeof(short));
	o+=sizeof(short);
//	int p=0;
//	while(p<=100){
//	printf("buff1: %hu\n", o[p]);
//	p++;
//	}
	//printf("length22: %d\n",  len+2*sizeof(short)); 
	return len+2*sizeof(short);
}

unsigned int rr2buf(char *o, dns_rr* rr) {
	int i = 0;
	uint16_t temp;
	uint32_t temp32;
	temp =  htons(49164); //这里指代1100000000001100，DNS报文中压缩指针的操作
	memcpy(o, &temp, sizeof(short)); 
	
//	printf("rr2leng: %d\n", strlen(rr->name));
//	memcpy(o,rr->name,strlen(rr->name)+1);
//	while(1){
//		printf("ccc: %c\n", o[i]);
//		i++;
//		if(i == 5) break;
//	}
//	printf("rrName: %s\n", o);
	o+=2;
	//printf("flag3\n");
	temp=htons(rr->type);
	memcpy(o, &temp, sizeof(short));
	//printf("rrType: %d\n", rr->type);
	o+=2;
	//printf("flag3\n");
	temp=htons(rr->rclass);
	memcpy(o, &temp, sizeof(short));
	o+=2;
	//printf("flag3\n");
	temp32=htonl(rr->ttl); //这里是htonl 32位数字的主机字节序转化 
	//printf("ttlconvert: %d\n", temp32);
	memcpy(o, &temp32, (2*sizeof(short)));
	o+=4;
	//printf("flag3\n");
	temp=htons(rr->data_len);
	memcpy(o, &temp, sizeof(short));
	o+=2;
	//printf("flag3\n");
	//这里指preference，MX里面要多两个字节哦
	if(rr->type == MX_TYPE){
		temp=htons(1);
		memcpy(o, &temp, sizeof(short));
		o+=2;
	}
	
	if(rr->type == A_TYPE){
		uint32_t  ipAddr = inet_addr(rr->rdata);
		memcpy(o, &ipAddr,rr->data_len); //将字符串转化为网络字节序的4bytes数据 
		//printf("rrDate: %s\n", o);
		o+=rr->data_len; //也就是要移动4位 
		return 16;
	}
	else if(rr->type == CNAME_TYPE){
		char* ini = o; //for initial
	uint8_t count = 0;
	int i = 0;
	int j = 1; //转换后计数 
	int tempts = 0;
	o++; //先往后移动一位 
	while(1){
		//printf("get: %c\n", rr->rdata[i]);
		if(rr->rdata[i] == '.'){
				memcpy(o-count-1, &count, sizeof(char));
				//printf("Count: %d\n", count);
				count = 0;
				o++; i++;
				tempts = 1;
				
		}
		else if(rr->rdata[i] == '\0'){
			memcpy(o, &(rr->rdata[i]), sizeof(char));
			memcpy(o-count-1, &count, sizeof(char));
			count = 0;
			break;
		}
		else{
			memcpy(o, &(rr->rdata[i]), sizeof(char));
			o++;
			i++;
			count++; 
		}
	}
		return 12 + rr->data_len + 1;
	}
	else if(rr->type == MX_TYPE){ //MX的情况
		char* ini = o; //for initial
	uint8_t count = 0;
	int i = 0;
	int j = 1; //转换后计数 
	int tempts = 0;
	o++; //先往后移动一位 
	while(1){
		//printf("get: %c\n", rr->rdata[i]);
		if(rr->rdata[i] == '.'){
				memcpy(o-count-1, &count, sizeof(char));
				//printf("Count: %d\n", count);
				count = 0;
				o++; i++;
				tempts = 1;
				break;
				
		}
		else if(rr->rdata[i] == '\0'){
			memcpy(o, &(rr->rdata[i]), sizeof(char));
			memcpy(o-count-1, &count, sizeof(char));
			count = 0;
			break;
		}
		else{
			memcpy(o, &(rr->rdata[i]), sizeof(char));
			o++;
			i++;
			count++; 
		}
	}
	o--;
	//printf("i=%d\n", i);
	temp =  htons(49164); //这里指代1100000000001100，DNS报文中压缩指针的操作
	memcpy(o, &temp, sizeof(short)); 
	return 16+i;
	}
	
	
}
 //用于MX的ip查询，放到addtion里面
unsigned int add2buf(char *o, dns_rr* rr, dns_query* query) {
	// printf("add2buf rrdata: %s\n", rr->rdata);
	// printf("datalength: %d\n", strlen(rr->rdata));
	int i = 0;
	uint16_t temp;
	uint32_t temp32;
	temp =  htons(49152+12+strlen(query->name)+2+4+14); //这里指代1100000000001100，DNS报文中压缩指针的操作
	memcpy(o, &temp, sizeof(short)); 
//	printf("rr2leng: %d\n", strlen(rr->name));
//	memcpy(o,rr->name,strlen(rr->name)+1);
//	while(1){
//		printf("ccc: %c\n", o[i]);
//		i++;
//		if(i == 5) break;
//	}
//	printf("rrName: %s\n", o);
	o+=2;
	temp=htons(rr->type);
	memcpy(o, &temp, sizeof(short));
	//printf("rrType: %d\n", rr->type);
	o+=2;

	temp=htons(rr->rclass);
	memcpy(o, &temp, sizeof(short));
	o+=2;

	temp32=htonl(rr->ttl); //这里是htonl 32位数字的主机字节序转化 
	//printf("ttlconvert: %d\n", temp32);
	memcpy(o, &temp32, (2*sizeof(short)));
	o+=4;

	temp=htons(rr->data_len);
	memcpy(o, &temp, sizeof(short));
	o+=2;

	
	
	uint32_t  ipAddr = inet_addr(rr->rdata);
	memcpy(o, &ipAddr, rr->data_len); //将字符串转化为网络字节序的4bytes数据 
	//printf("rrDate: %d\n", ipAddr);
	o+=rr->data_len; //也就是要移动4位 
	return 16;


}

 int isequal(char *str1, char* str2)
{
    if (strlen(str1)!=strlen(str2))
     return 0;
     int i=0;
    for (i = 0; str1[i]!='\0'; i++){
        if (str1[i]!=str2[i])
        return 0;
     }
   return 1;
  }
eduC.txt文件如下：
yzy.edu.cn 86400 IN CNAME yzy.shiyan.dns
wyx.edu.cn 86400 IN CNAME wyx.shiyan.dns
eduM.txt文件如下：
ddd.edu.cn 86400 IN MX mail.ddd.edu.cn
aaa.edu.cn 86400 IN MX mail.aaa.edu.cn
exec.sh文件如下：
files=(*)

for file in "${files[@]}"
do
    if [[ -f $file ]]; then
        echo "$file文件如下：" >> demo.txt
        cat "$file" >> demo.txt
        echo "" >> demo.txt
    fi
done

govA.txt文件如下：
wyx.gov.us 86400 IN A 192.168.9.9
dns.gov.us 86400 IN A 192.168.100.100
mail.qq.gov.us 86400 IN A 192.168.101.101
mail.qwqw.gov.us 86400 IN A 192.168.102.102

gov.c文件如下：
#include<stdio.h>
#include<sys/types.h>
#include<string.h>
#include<unistd.h>
#include<netinet/in.h>
#include<sys/socket.h>
#include<unistd.h>
#include<stdlib.h>
#include<netinet/in.h>
#include<arpa/inet.h>
#include<stdint.h>
#include "DNS.h"
#define LINE     10
#define DNS_MAX_LENGTH 1023

unsigned int getHeader(char *q, dns_header *header);
unsigned int getQuery(char *q, dns_query *query);
int isequal(char *str1, char* str2);
unsigned int rr2buf(char *o, dns_rr* rr);
unsigned int query2buf(char *o, dns_query *query);
unsigned int head2buf(char *o, dns_header *header);
unsigned int add2buf(char *o, dns_rr* rr, dns_query* query);
void init_sockaddr_in(char* ip, int port, struct sockaddr_in* addr);
int main(){
	int state=0;  //查到没有 
	int sockup;
	struct sockaddr_in localAddr;
	struct sockaddr_in upAddr;
	struct sockaddr_in downAddr;
	unsigned int upAddrLen;
	char upInBuffer[DNS_MAX_LENGTH];
	char upOutBuffer[DNS_MAX_LENGTH];
	unsigned short port=53;
	int recvMsgSize;
	int outMsgSize; 
	char ipAddr[100];
	//不需要分割名字，因为已经是最底层服务器，拿文件查询即可 
	
	//接受的结构体 
	dns_query *recvQuery = (dns_query *)malloc(sizeof(dns_query));initQuery(recvQuery);
	dns_header *recvHead = (dns_header *)malloc(sizeof(dns_header));initHead(recvHead);
	dns_rr *recvrRecord = (dns_rr *)malloc(sizeof(dns_rr));initRR(recvrRecord);  
	//回应的结构体 
	dns_query *resQuery = (dns_query *)malloc(sizeof(dns_query));initQuery(resQuery);
	dns_header *resHead = (dns_header *)malloc(sizeof(dns_header));initHead(resHead);
	dns_rr *resRecord = (dns_rr *)malloc(sizeof(dns_rr));initRR(resRecord); 
	//MX第二次查询ip
	dns_query *mxQuery = (dns_query *)malloc(sizeof(dns_query));initQuery(mxQuery);
	dns_header *mxHead = (dns_header *)malloc(sizeof(dns_header));initHead(mxHead);
	dns_rr *mxRecord = (dns_rr *)malloc(sizeof(dns_rr));initRR(mxRecord);
	
	
	if((sockup=socket(PF_INET,SOCK_DGRAM,0))<0)  printf("socket() failed\n");
	
	init_sockaddr_in("127.0.0.7", 53, &localAddr);
	if((bind (sockup,(struct sockaddr*)&localAddr,sizeof(localAddr)))<0){
		printf("bind() failed\n");
	} 
	while(1){
	state=0;
	upAddrLen=sizeof(upAddr);
	//receive
	if((recvMsgSize=recvfrom(sockup,upInBuffer,DNS_MAX_LENGTH,0,(struct sockaddr*)&upAddr,&upAddrLen))<0){
		printf("recvfrom() failed\n");
	}
	printf("Handling client %s\n",inet_ntoa(upAddr.sin_addr));
	
	//解析 
	char *i = upInBuffer;
	i += getHeader(i, recvHead);
	i += getQuery(i, recvQuery); 	
	//printf("The domain name is: %s\n", recvQuery->name);
	
    //以下为回应的部分
	resHead->id =htons(recvHead->id);
	resHead->tag =htons(0x8000);
	resHead->queryNum =htons(recvHead->queryNum);
	resHead->answerNum = htons(1); //这里不一定是1，若没查到怎么办？？ 
	resHead->authorNum = 0;
	resHead->addNum = 0;
	resQuery = recvQuery;
	resRecord->name=recvQuery->name;
    resRecord->rclass=recvQuery->qclass;
	resRecord->type=recvQuery->qtype;
	resRecord->ttl = (uint32_t)86400;
	resRecord->data_len = 4;
	
	/*
	 *返回查询结果 
	 */
	 if(recvQuery->qtype==A_TYPE){
	   freopen("govA.txt", "r", stdin);
	   char file_name[255],file_ttl[255],file_class[255],file_type[255],file_ip[255];
	    while(~scanf("%s%s%s%s%s", file_name, file_ttl, file_class,file_type,file_ip)){
	    	if(isequal(recvQuery->name,file_name)){
	    		printf("file_name: %s\n",file_name);
	    		printf("file_ttl: %s\n",file_ttl);
	    		printf("file_class； %s\n",file_class);
	    		printf("file_type: %s\n",file_type);
	    		printf("file_ip: %s\n",file_ip);
	    		//printf("recv->Query: %s\n",recvQuery->name);
	    		//在结构体里把rdata赋值为 file_ip ,在head里把anwernum赋值为1,flag为8180 
	    		resRecord->name = (char*)malloc((strlen(file_name)+1)*sizeof(char));
				strcpy(resRecord->name, file_name);
				resRecord->ttl = (uint32_t)(atoi(file_ttl));
				resRecord->rdata = (char*)malloc((strlen(file_ip)+1)*sizeof(char));
				strcpy(resRecord->rdata, file_ip);
				resRecord->data_len=strlen(resRecord->rdata)+1;
				resHead->answerNum = htons(1);
				resHead->tag = htons(0x8180);
	    		state=1;   //表明查到 
	    		break;
			}
		}  
	}
	else if(recvQuery->qtype==CNAME_TYPE){
	 freopen("govC.txt", "r", stdin);
	   char file_name[255],file_ttl[255],file_class[255],file_type[255],file_addr[255];
	    while(~scanf("%s%s%s%s%s", file_name, file_ttl, file_class,file_type,file_addr)){
	    	if(isequal(recvQuery->name,file_name)){
	    		printf("file_name: %s\n",file_name);
	    		printf("file_ttl: %s\n",file_ttl);
	    		printf("file_class； %s\n",file_class);
	    		printf("file_type: %s\n",file_type);
	    		printf("file_addr: %s\n",file_addr);
	    		//printf("recv->Query: %s\n",recvQuery->name);
	    		//在结构体里把rdata赋值为 file_ip ,在head里把anwernum赋值为1,flag为8180 
	    		resRecord->name = (char*)malloc((strlen(file_name)+1)*sizeof(char));
				strcpy(resRecord->name, file_name);
				resRecord->ttl = (uint32_t)(atoi(file_ttl));
				resRecord->rdata = (char*)malloc((strlen(file_addr)+1)*sizeof(char));
				strcpy(resRecord->rdata, file_addr);
				resRecord->data_len=strlen(resRecord->rdata)+1;
				resHead->answerNum = htons(1);
				resHead->tag = htons(0x8180);
	    		state=1;   //表明查到 
	    		break;
			}
		}  	
	}
	else if(recvQuery->qtype==MX_TYPE){
		//printf("in file M\n");
		freopen("govM.txt", "r", stdin);
		printf("flag1\n"); 
	   char file_name[255],file_ttl[255],file_class[255],file_type[255],file_addr[255];
	    while(~scanf("%s%s%s%s%s", file_name, file_ttl, file_class,file_type,file_addr)){
	    	//printf("flag2\n");
	    	if(isequal(recvQuery->name,file_name)){
	    		printf("file_name: %s\n",file_name);
	    		printf("file_name length: %d\n",strlen(file_name));
	    		printf("file_ttl: %s\n",file_ttl);
	    		printf("file_class； %s\n",file_class);
	    		printf("file_type: %s\n",file_type);
	    		printf("file_addr: %s\n",file_addr);
				//不确定你从文件里读出来的是什么样子的，含不含空格，长度下面有可能不对

				resRecord->name = (char*)malloc((strlen(file_name)+1)*sizeof(char));
				strcpy(resRecord->name, file_name);
				resRecord->ttl = (uint32_t)(atoi(file_ttl));
				resRecord->rdata = (char*)malloc((strlen(file_addr)+1)*sizeof(char));
				strcpy(resRecord->rdata, file_addr);
				resHead->answerNum = htons(1);
				//这里用现在的域名减去查询的名字长度再+2(pre..)+2(压缩指针)
		        resRecord->data_len = strlen(resRecord->rdata)-strlen(recvQuery->name) + 4;
				resHead->tag = htons(0x8180);

	    		//printf("recv->Query: %s\n",recvQuery->name);
	    		//在结构体里把rdata赋值为 file_ip ,在head里把anwernum赋值为1，flag为8180 
	    		state=1;   //表明查到 
	    		break;
			}
		} 
		if(state==1){
		mxQuery->name = (char*)malloc((strlen(resRecord->rdata)+1)*sizeof(char));
		strcpy(mxQuery->name, resRecord->rdata);
		//printf("mxQueryName: %s\n", mxQuery->name);
		mxQuery->qclass = recvQuery->qclass;
		mxQuery->qtype = A_TYPE; //这里要用上一次的结果A方式查询一下
		freopen("govA.txt", "r", stdin);
	    char file_ip[255];
	    while(~scanf("%s%s%s%s%s", file_name, file_ttl, file_class,file_type,file_ip)){
	    	if(isequal(mxQuery->name,file_name)){
	    		printf("file_name: %s\n",file_name);
	    		printf("file_name length: %d\n",strlen(file_name));
	    		printf("file_ttl: %s\n",file_ttl);
	    		printf("file_class； %s\n",file_class);
	    		printf("file_type: %s\n",file_type);
	    		printf("file_ip: %s\n",file_ip);
				//不确定你从文件里读出来的是什么样子的，含不含空格，长度下面有可能不对	
		    	mxRecord->name = (char*)malloc((strlen(file_name)+1)*sizeof(char));
				strcpy(mxRecord->name, file_name);
				mxRecord->ttl = (uint32_t)(atoi(file_ttl));
				mxRecord->rdata = (char*)malloc((strlen(file_addr)+1)*sizeof(char));
				strcpy(mxRecord->rdata, file_ip);
				mxRecord->data_len=4;
				mxRecord->type=A_TYPE; 
	            mxRecord->rclass=recvQuery->qclass;
                resHead->addNum = htons(1); 

	    		//printf("recv->Query: %s\n",recvQuery->name);
	    		//在结构体里把rdata赋值为 file_ip ,在head里把anwernum赋值为1，flag为8180 
	    		state=1;   //表明查到 
	    		break;
			}
		}
	  }
	 }
	 	  
	//printf("state %d\n",state);
	char* o=upOutBuffer;
	if(state==0){
		resHead->tag =htons(0x8183);
		resHead->answerNum = 0;
	 	o = upOutBuffer; 
		o += head2buf(o, resHead);
	 	o += query2buf(o,resQuery);    
	}else{
		o = upOutBuffer; 
	 	o += head2buf(o, resHead);
	 	o += query2buf(o,resQuery); 
	 	o += rr2buf(o,resRecord);
	 	if(recvQuery->qtype == MX_TYPE)
	 	o+=add2buf(o, mxRecord, recvQuery);
	}
    
    
	 

	//统一返回
	//把upOutBuffer赋值 
	outMsgSize = o - upOutBuffer + 1;
	//printf("length:%d \n",outMsgSize);
	if(sendto(sockup,upOutBuffer,outMsgSize,0,(struct sockaddr*)&upAddr,sizeof(upAddr))!=outMsgSize){
		printf("sendto() problem!\n");
	}
  }
	
}	
unsigned int head2buf(char *o, dns_header *head){
	memcpy(o, head, sizeof(dns_header));
	//////////////////////////////////////////////没转主机字节序！！！！！ 
	return sizeof(dns_header);
}

void init_sockaddr_in(char* ip, int port, struct sockaddr_in* addr){
    addr->sin_family = AF_INET;
    addr->sin_port = htons(port);
    addr->sin_addr.s_addr=inet_addr(ip);
    memset(addr->sin_zero, 0, sizeof(addr->sin_zero));
}

unsigned int getHeader(char *q, dns_header *header){
	// int i = 0;
	// while(1){
	// 	if(i<100){
	// 		printf("headerIn: %d\n", q[i]);i++;
	// 	}
		
	// 	else break;
	// }
	
	header->id = ntohs(*(uint16_t*) (q));
	header->tag = ntohs(*(uint16_t*) (q+2));
	header->queryNum = ntohs(*(uint16_t*) (q+4));
	printf("queryName: %d\n", header->id);
	header->answerNum = ntohs(*(uint16_t*) (q+6));
	header->authorNum = ntohs(*(uint16_t*) (q+8));
	header->addNum = ntohs(*(uint16_t*) (q+10));
	
	return sizeof(dns_header);
}

//下面这三个函数和localServer中的一样，可以考虑打包进.h 
unsigned int getQuery(char *q, dns_query *query){
	char domainName[100];
	memset(domainName, 0, 100);
	char *d = domainName;
	printf("d: %s\n", d);
	uint8_t count = 0;
	int i = 0; 
	//count = ntohs(*(uint8_t*)(q));
	//完成报文中数字加域名形式至点分值的转换 
	while(1){
		if(*q!='\0'){
			count = *(uint8_t*)(q);
			//printf("count:%d\n", count);
			q++;
			while(count){
				//printf("i: %d\n", i);
				//printf("char1:%c\n", *q);
				memcpy(&(domainName[i]), q, sizeof(char));
				//printf("domain name i: %c\n", domainName[i]);
				count--; q++; i++;
			}
			domainName[i] = '.'; //加点 
			i++;
		}
		else{
			domainName[i-1] = '\0'; //标注结束 
			q++; 
			break;
		}
	}
	// printf("i: %d\n", i);  
	// printf("Converted domain name: %s\n", domainName);
	// printf("length: %d\n", i);
	query->name = (char*)malloc(i*sizeof(char));
	memcpy(query->name, domainName, i); //此时的i便为转换后变长字符串的长度了，经过了循环遍历 
	//printf("Query name: %s\n", query->name);
	
	query->qtype = ntohs(*(uint16_t*) (q));
	query->qclass = ntohs(*(uint16_t*) (q+2));
	//printf("Query Type: %d\n", query->qtype);
	//printf("Query Class: %d\n", query->qclass);
	return i+4+1; //补一个1的原因是网络的域名形式和转换后的差一位 
}

unsigned int query2buf(char *o, dns_query *query){
	char* ini = o; //for initial
	uint8_t count = 0;
	int i = 0;
	int j = 1; //转换后计数 
	int tempts = 0;
	o++; //先往后移动一位 
	while(1){
		//printf("get: %c\n", query->name[i]);
		if(query->name[i] == '.'){
				memcpy(o-count-1, &count, sizeof(char));
				//printf("Count: %d\n", count);
				count = 0;
				o++; i++;
				tempts = 1;
				
		}
		else if(query->name[i] == '\0'){
			memcpy(o, &(query->name[i]), sizeof(char));
			memcpy(o-count-1, &count, sizeof(char));
			count = 0;
			break;
		}
		else{
			memcpy(o, &(query->name[i]), sizeof(char));
			o++;
			i++;
			count++; 
		}
	}
	o++;
	int len = o - ini; //计算出名字的长度
	//printf("length: %d\n", len); 
	uint16_t temp = htons(query->qtype);
	memcpy(o, &temp, sizeof(short));
	temp = htons(query->qclass);
	o+=sizeof(short);
	memcpy(o, &temp, sizeof(short));
	o+=sizeof(short);
//	int p=0;
//	while(p<=100){
//	printf("buff1: %hu\n", o[p]);
//	p++;
//	}
	//printf("length22: %d\n",  len+2*sizeof(short)); 
	return len+2*sizeof(short);
}

unsigned int rr2buf(char *o, dns_rr* rr) {
	int i = 0;
	uint16_t temp;
	uint32_t temp32;
	temp =  htons(49164); //这里指代1100000000001100，DNS报文中压缩指针的操作
	memcpy(o, &temp, sizeof(short)); 
	
//	printf("rr2leng: %d\n", strlen(rr->name));
//	memcpy(o,rr->name,strlen(rr->name)+1);
//	while(1){
//		printf("ccc: %c\n", o[i]);
//		i++;
//		if(i == 5) break;
//	}
//	printf("rrName: %s\n", o);
	o+=2;
	//printf("flag3\n");
	temp=htons(rr->type);
	memcpy(o, &temp, sizeof(short));
	//printf("rrType: %d\n", rr->type);
	o+=2;
	//printf("flag3\n");
	temp=htons(rr->rclass);
	memcpy(o, &temp, sizeof(short));
	o+=2;
	//printf("flag3\n");
	temp32=htonl(rr->ttl); //这里是htonl 32位数字的主机字节序转化 
	//printf("ttlconvert: %d\n", temp32);
	memcpy(o, &temp32, (2*sizeof(short)));
	o+=4;
	//printf("flag3\n");
	temp=htons(rr->data_len);
	memcpy(o, &temp, sizeof(short));
	o+=2;
	//printf("flag3\n");
	//这里指preference，MX里面要多两个字节哦
	if(rr->type == MX_TYPE){
		temp=htons(1);
		memcpy(o, &temp, sizeof(short));
		o+=2;
	}
	
	if(rr->type == A_TYPE){
		uint32_t  ipAddr = inet_addr(rr->rdata);
		memcpy(o, &ipAddr,rr->data_len); //将字符串转化为网络字节序的4bytes数据 
		//printf("rrDate: %s\n", o);
		o+=rr->data_len; //也就是要移动4位 
		return 16;
	}
	else if(rr->type == CNAME_TYPE){
		char* ini = o; //for initial
	uint8_t count = 0;
	int i = 0;
	int j = 1; //转换后计数 
	int tempts = 0;
	o++; //先往后移动一位 
	while(1){
		//printf("get: %c\n", rr->rdata[i]);
		if(rr->rdata[i] == '.'){
				memcpy(o-count-1, &count, sizeof(char));
				//printf("Count: %d\n", count);
				count = 0;
				o++; i++;
				tempts = 1;
				
		}
		else if(rr->rdata[i] == '\0'){
			memcpy(o, &(rr->rdata[i]), sizeof(char));
			memcpy(o-count-1, &count, sizeof(char));
			count = 0;
			break;
		}
		else{
			memcpy(o, &(rr->rdata[i]), sizeof(char));
			o++;
			i++;
			count++; 
		}
	}
		return 12 + rr->data_len + 1;
	}
	else if(rr->type == MX_TYPE){ //MX的情况
		char* ini = o; //for initial
	uint8_t count = 0;
	int i = 0;
	int j = 1; //转换后计数 
	int tempts = 0;
	o++; //先往后移动一位 
	while(1){
		//printf("get: %c\n", rr->rdata[i]);
		if(rr->rdata[i] == '.'){
				memcpy(o-count-1, &count, sizeof(char));
				//printf("Count: %d\n", count);
				count = 0;
				o++; i++;
				tempts = 1;
				break;
				
		}
		else if(rr->rdata[i] == '\0'){
			memcpy(o, &(rr->rdata[i]), sizeof(char));
			memcpy(o-count-1, &count, sizeof(char));
			count = 0;
			break;
		}
		else{
			memcpy(o, &(rr->rdata[i]), sizeof(char));
			o++;
			i++;
			count++; 
		}
	}
	o--;
	//printf("i=%d\n", i);
	temp =  htons(49164); //这里指代1100000000001100，DNS报文中压缩指针的操作
	memcpy(o, &temp, sizeof(short)); 
	return 16+i;
	}
	
	
}

 //用于MX的ip查询，放到addtion里面
unsigned int add2buf(char *o, dns_rr* rr, dns_query* query) {
	//printf("add2buf rrdata: %s\n", rr->rdata);
	//printf("datalength: %d\n", strlen(rr->rdata));
	int i = 0;
	uint16_t temp;
	uint32_t temp32;
	temp =  htons(49152+12+strlen(query->name)+2+4+14); //这里指代1100000000001100，DNS报文中压缩指针的操作
	memcpy(o, &temp, sizeof(short)); 
//	printf("rr2leng: %d\n", strlen(rr->name));
//	memcpy(o,rr->name,strlen(rr->name)+1);
//	while(1){
//		printf("ccc: %c\n", o[i]);
//		i++;
//		if(i == 5) break;
//	}
//	printf("rrName: %s\n", o);
	o+=2;
	temp=htons(rr->type);
	memcpy(o, &temp, sizeof(short));
	//printf("rrType: %d\n", rr->type);
	o+=2;

	temp=htons(rr->rclass);
	memcpy(o, &temp, sizeof(short));
	o+=2;

	temp32=htonl(rr->ttl); //这里是htonl 32位数字的主机字节序转化 
	//printf("ttlconvert: %d\n", temp32);
	memcpy(o, &temp32, (2*sizeof(short)));
	o+=4;

	temp=htons(rr->data_len);
	memcpy(o, &temp, sizeof(short));
	o+=2;

	
	
	uint32_t  ipAddr = inet_addr(rr->rdata);
	memcpy(o, &ipAddr, rr->data_len); //将字符串转化为网络字节序的4bytes数据 
	//printf("rrDate: %d\n", ipAddr);
	o+=rr->data_len; //也就是要移动4位 
	return 16;


}
 int isequal(char *str1, char* str2)
{
    if (strlen(str1)!=strlen(str2))
     return 0;
     int i=0;
    for (i = 0; str1[i]!='\0'; i++){
        if (str1[i]!=str2[i])
        return 0;
     }
   return 1;
  }
govC.txt文件如下：
wyx.gov.us 86400 IN CNAME wyx.dns.shiyan
dns.gov.us 86400 IN CNAME yzy.dns.shiyan
govM.txt文件如下：
qq.gov.us 86400 IN MX mail.qq.gov.us
qwqw.gov.us 86400 IN MX mail.qwqw.gov.us
localCacheA.txt文件如下：
wyx.yzy.dns 86400 IN A 192.168.1.25
qmul.shiyan.dns 86400 IN A 188.130.100.98
mail.bupt.edu.cn 86400 IN A 185.229.250.34
mail.qmul.ac.uk 86400 IN A 156.229.250.3

localCacheC.txt文件如下：
wyx.yzy.dns 86400 IN CNAME cname.shiyan.dns
qmul.dns.shiyan 86400 IN CNAME cname.qmul.shiyan
localCacheMX.txt文件如下：
bupt.edu.cn 86400 IN MX mail.bupt.edu.cn
qmul.ac.uk 86400 IN MX mail.qmul.ac.uk


localServer.c文件如下：
#include <stdio.h>
#include <sys/types.h>
#include <string.h>
#include <unistd.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <unistd.h>
#include <stdlib.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <stdint.h>

#include "DNS.h"
#define LINE 10
#define DNS_MAX_LENGTH 1023
// 创建TCP服务器实现服务器和客户端的通信
unsigned int getHeader(char *q, dns_header *header);
unsigned int getQuery(char *q, dns_query *recvQuery);
void init_DNS_RR(dns_query *recvQuery, dns_rr *resRecord, char *col);
unsigned int head2buf(char *o, dns_header *head);
unsigned int query2buf(char *o, dns_query *query);
unsigned int add2buf(char *o, dns_rr *rr, dns_query *query);
unsigned int rr2buf(char *o, dns_rr *rr);
unsigned int compare(dns_query *query, char *col);
unsigned int cmpDomainName(char *name, char *col);
unsigned int cmpTypeClass(unsigned short type, char *col);
unsigned int getRRs(char *q, dns_rr *rRecord);
void init_sockaddr_in(char *ip, int port, struct sockaddr_in *addr);

int main()
{
	// 创建socket套接字
	int serfd = 0;
	serfd = socket(AF_INET, SOCK_STREAM, 0);
	if (serfd < 0)
	{
		perror("socket failed");
		return -1;
	}
	printf("Socket Created!\n");
	// 通过调用bind绑定IP地址和端口号
	int ret = 0;
	struct sockaddr_in seraddr = {0};
	seraddr.sin_family = AF_INET;
	seraddr.sin_port = htons(53);
	seraddr.sin_addr.s_addr = inet_addr("127.0.0.2");
	ret = bind(serfd, (struct sockaddr *)&seraddr, sizeof(seraddr));
	if (ret < 0)
	{
		perror("Bind failed");
		close(serfd);
		return -1;
	}
	printf("Bind Starting\n");
	// 通过调用listen将套接字设置为监听模式
	int lis = 0;
	lis = listen(serfd, LINE);
	if (lis < 0)
	{
		perror("listen failed");
		close(serfd);
		return -1;
	}
	printf("Listen to the client\n");
	// 服务器等待客户端连接中，游客户端连接时调用accept产生一个新的套接字
	int confd = 0;
	socklen_t addrlen;
	struct sockaddr_in clientaddr = {0};
	addrlen = sizeof(clientaddr);
	confd = accept(serfd, (struct sockaddr *)&clientaddr, &addrlen);
	if (confd < 0)
	{
		perror("accept failed");
		close(serfd);
		return -1;
	}
	printf("Connect with Client successfully!\n");
	printf("IP=%s, PORT=%u\n", inet_ntoa(clientaddr.sin_addr), ntohs(clientaddr.sin_port));
	// 调用recv接收客户端的消息

	while (1)
	{
		/*
		 *声明
		 */
		unsigned char queryInfo[127];
		unsigned char *convertQueryInfo;
		// 接受的结构体
		dns_query *recvQuery = (dns_query *)malloc(sizeof(dns_query));
		initQuery(recvQuery);
		dns_header *recvHead = (dns_header *)malloc(sizeof(dns_header));
		initHead(recvHead);
		dns_rr *recvrRecord = (dns_rr *)malloc(sizeof(dns_rr));
		initRR(recvrRecord);
		// 回应的结构体
		dns_query *resQuery = (dns_query *)malloc(sizeof(dns_query));
		initQuery(resQuery);
		dns_header *resHead = (dns_header *)malloc(sizeof(dns_header));
		initHead(resHead);
		dns_rr *resRecord = (dns_rr *)malloc(sizeof(dns_rr));
		initRR(resRecord);
		// 接收DNS服务器传来的结构体
		dns_query *serverQuery = (dns_query *)malloc(sizeof(dns_query));
		initQuery(serverQuery);
		dns_header *serverHead = (dns_header *)malloc(sizeof(dns_header));
		initHead(serverHead);
		dns_rr *serverRecord = (dns_rr *)malloc(sizeof(dns_rr));
		initRR(serverRecord);
		// MX第二次查询ip
		dns_query *mxQuery = (dns_query *)malloc(sizeof(dns_query));
		initQuery(mxQuery);
		dns_header *mxHead = (dns_header *)malloc(sizeof(dns_header));
		initHead(mxHead);
		dns_rr *mxRecord = (dns_rr *)malloc(sizeof(dns_rr));
		initRR(mxRecord);

		char bufOut[DNS_MAX_LENGTH];
		memset(bufOut, 0, DNS_MAX_LENGTH);
		char bufIn[DNS_MAX_LENGTH];
		memset(bufIn, 0, DNS_MAX_LENGTH);
		char closeFlag[5];
		char flag[] = "exit";

		unsigned short qType, qClass;
		unsigned short offset = 0;
		unsigned short *offsetptr;
		int rev = 0;
		int sed = 0;
		int checkinit = 0;

		while (1)
		{
			/*
			 *清空原有buff，初始化
			 */
			checkinit = 0;
			memset(bufOut, 0, DNS_MAX_LENGTH);
			memset(bufIn, 0, DNS_MAX_LENGTH);
			char *o = bufOut + 2; // 开头留两字节显示大小便于抓包
			char *i = bufIn + 2;  // 接收的时候把前2字节跳过
			offset = 0;
			rev = 0;

			/*
			 *接收
			 */
			rev = recv(confd, bufIn, sizeof(bufIn), 0);
			// printf("ss: %s\n", bufIn);
			i += getHeader(i, recvHead);
			i += getQuery(i, recvQuery);
			if (rev > 0)
			{
				printf("Received the query request from client!\n");

				// int i=0;
				// for(i=0;i<rev;i++){
				// 	printf("%d ",bufIn[i]);
				// }
				// printf("\n");
			}
			// 关闭接口函数
			if (recvQuery->qtype == 0)
			{
				close(confd);
				break;
			}

			/*
			 *解析接口（头）
			 */
			resHead->id = htons(recvHead->id);
			resHead->tag = htons(0x8180);
			resHead->queryNum = htons(recvHead->queryNum);
			resHead->answerNum = htons(1); // 这里不一定是1，若没查到怎么办？？
			resHead->authorNum = 0;
			resHead->addNum = 0;
			resQuery = recvQuery;
			char *filePath;
			// printf("type1: %d\n", resQuery->qtype);
			// printf("type2: %d\n", recvQuery->qtype);
			// 读文件的代码 A
			if (resQuery->qtype == A_TYPE)
			{
				filePath = "localCacheA.txt";
				FILE *fp = fopen(filePath, "r"); // 读取对应文件
				char col[DNSMAXLEN];
				memset(col, 0, DNSMAXLEN);
				while (fgets(col, DNSMAXLEN - 1, fp) != NULL)
				{ // 逐行对比
					// printf("in compare whileA\n");
					if (compare(recvQuery, col))
					{
						// printf("in compareA\n");
						init_DNS_RR(recvQuery, resRecord, col);
						resHead->answerNum = htons(1); // 找到answer，在answerNum处赋值
						checkinit = 1;				   // 表明查询完成，无需再进入下一节点查询
						break;
					}
				}
			}
			else if (resQuery->qtype == CNAME_TYPE)
			{
				filePath = "localCacheC.txt";
				FILE *fp = fopen(filePath, "r"); // 读取对应文件
				char col[DNSMAXLEN];
				memset(col, 0, DNSMAXLEN);
				while (fgets(col, DNSMAXLEN - 1, fp) != NULL)
				{ // 逐行对比
					// printf("in compare whileC\n");
					if (compare(recvQuery, col))
					{
						// printf("in compareC\n");
						init_DNS_RR(recvQuery, resRecord, col);
						resHead->answerNum = htons(1); // 找到answer，在answerNum处赋值
						checkinit = 1;				   // 表明查询完成，无需再进入下一节点查询
						break;
					}
				}
			}
			else if (resQuery->qtype == MX_TYPE)
			{
				// 第一次先去查一下邮箱服务器地址
				filePath = "localCacheMX.txt";
				FILE *fp1 = fopen(filePath, "r"); // 读取对应文件
				char col1[DNSMAXLEN];
				memset(col1, 0, DNSMAXLEN);
				while (fgets(col1, DNSMAXLEN - 1, fp1) != NULL)
				{ // 逐行对比
					// printf("in compare whileMX\n");
					if (compare(recvQuery, col1))
					{
						// printf("in compareMX\n");
						init_DNS_RR(recvQuery, resRecord, col1);
						resHead->answerNum = htons(1); // 找到answer，在answerNum处赋值
						checkinit = 1;				   // 表明查询完成，无需再进入下一节点查询
						break;
					}
				}
				if (checkinit == 1)
				{
					mxQuery->name = (char *)malloc((strlen(resRecord->rdata) + 1) * sizeof(char));
					strcpy(mxQuery->name, resRecord->rdata);
					// printf("mxQueryName: %s\n", mxQuery->name);
					mxQuery->qclass = recvQuery->qclass;
					mxQuery->qtype = A_TYPE; // 这里要用上一次的结果A方式查询一下

					// 第二次先去查一下ip地址	A
					filePath = "localCacheA.txt";
					FILE *fp2 = fopen(filePath, "r"); // 读取对应文件
					char col2[DNSMAXLEN];
					memset(col2, 0, DNSMAXLEN);
					while (fgets(col2, DNSMAXLEN - 1, fp2) != NULL)
					{ // 逐行对比
						// printf("in compare whileMX2\n");
						if (compare(mxQuery, col2))
						{
							// printf("in compareMX2\n");
							init_DNS_RR(mxQuery, mxRecord, col2);
							resHead->addNum = htons(1); // 找到answer，在answerNum处赋值
							checkinit = 1;				// 表明查询完成，无需再进入下一节点查询
							break;
						}
					}
				}
			}

			/*
			 *向root查询
			 */
			if (checkinit != 1)
			{
				int sockudp;
				struct sockaddr_in toAddr;	 // 去的地址
				struct sockaddr_in fromAddr; // 本机的地址
				unsigned short toPort = 53;
				unsigned int fromSize;

				char bufFromRoot[DNS_MAX_LENGTH];
				memset(bufFromRoot, 0, DNS_MAX_LENGTH);

				char *askBuf;
				askBuf = bufIn + 2;
				char recvBuffer[DNS_MAX_LENGTH];
				// char askBuffer[DNS_MAX_LENGTH];

				// int outLength; //发出的长度
				int inLength; // 收到的字节长度

				if ((sockudp = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP)) < 0)
					printf("socket() failed\n");
				init_sockaddr_in("127.0.0.3", 53, &toAddr);
				printf("Query to Root\n");
				/*
				 *send
				 */
				if (sendto(sockudp, askBuf, DNS_MAX_LENGTH, 0, (struct sockaddr *)&toAddr, sizeof(toAddr)) != DNS_MAX_LENGTH)
				{
					printf("send length not right.\n");
				}
				/*
				 *recv 从根节点接收
				 */
				fromSize = sizeof(fromAddr);
				inLength = recvfrom(sockudp, bufFromRoot, DNS_MAX_LENGTH, 0, (struct sockaddr *)&fromAddr, &fromSize);
				// printf("buf: %s\n", bufFromRoot);
				// printf("length: %d\n", inLength);
				// bufFromRoot[inLength]='\0';
				char *p = bufFromRoot; // 初始化下面服务器传来的指针
				p += getHeader(p, serverHead);
				// printf("Head Tag From Root: %d\n", serverHead->tag);
				p += getQuery(p, serverQuery);
				serverRecord->name = serverQuery->name;
				serverRecord->type = A_TYPE;
				serverRecord->rclass = serverQuery->qclass;
				// printf("rRecord Name: %s\n", serverRecord->name);
				// printf("rRecord Type: %d\n", serverRecord->type);
				// printf("rRecord Class: %d\n", serverRecord->rclass);
				// printf("size1: %d\n", strlen(serverRecord->name)+1);
				// printf("size2: %d\n", 2*sizeof(serverRecord->type));
				p += 6; // 压缩指针那两个字节和后面的2个type，共6字节
				// printf("strlen offset: %d\n", strlen(serverRecord->name)+1);
				// i += (2*sizeof(serverRecord->type));
				// printf("sizeof2: %d\n", 2*sizeof(serverRecord->type));
				// 在这里送去解析的只有rr的后几个值
				p += getRRs(p, serverRecord);
				// printf("The next query ipAddr: %s\n", serverRecord->rdata);
				/*
				 *迭代遍历
				 */
				while (1)
				{
					if (serverHead->tag == 32768)
					{								// 8000
						struct sockaddr_in askAddr; // 下一阶段问的地址
						unsigned int askSize;		// 返回的地址长度
						int backlength;				// 返回的字节长度
						printf("Send Query Request to %s\n", serverRecord->rdata);
						init_sockaddr_in(serverRecord->rdata, 53, &askAddr);

						if (sendto(sockudp, askBuf, DNS_MAX_LENGTH, 0, (struct sockaddr *)&askAddr, sizeof(askAddr)) != DNS_MAX_LENGTH)
						{
							printf("send length not right.\n");
						}
						askSize = sizeof(askAddr);
						backlength = recvfrom(sockudp, bufFromRoot, DNS_MAX_LENGTH, 0, (struct sockaddr *)&askAddr, &askSize);
						// printf("backlength: %d\n",backlength) ;

						/*
						 *这段解析代码可以弄个函数
						 */
						char *p1 = bufFromRoot; // 初始化下面服务器传来的指针
						p1 += getHeader(p1, serverHead);
						// printf("Head Tag From diedai: %d\n", serverHead->tag);
						p1 += getQuery(p1, serverQuery);
						serverRecord->name = serverQuery->name;
						if (serverHead->tag == 32768)
						{
							serverRecord->type = A_TYPE;
						}
						else
							serverRecord->type = serverQuery->qtype;
						serverRecord->rclass = serverQuery->qclass;
						// printf("dd rRecord Name: %s\n", serverRecord->name);
						// printf("dd rRecord Type: %d\n", serverRecord->type);
						// printf("dd rRecord Class: %d\n", serverRecord->rclass);
						// printf("dd size1: %d\n", strlen(serverRecord->name)+1);
						// printf("dd size2: %d\n", 2*sizeof(serverRecord->type));
						p1 += 6; // 压缩指针那两个字节和后面的2个type，共6字节
						// printf("dd strlen offset: %d\n", strlen(serverRecord->name)+1);
						// i += (2*sizeof(serverRecord->type));
						// printf("dd sizeof2: %d\n", 2*sizeof(serverRecord->type));
						// 在这里送去解析的只有rr的后几个值
						if (serverHead->tag != 33155)
						{
							p1 += getRRs(p1, serverRecord);
							if (serverQuery->qtype == MX_TYPE)
							{
								mxRecord->name = (char *)malloc((strlen(serverRecord->rdata) + 1) * sizeof(char));
								strcpy(mxRecord->name, serverRecord->rdata);
								mxRecord->type = A_TYPE;
								mxRecord->rclass = 1;
								p1 += getRRs(p1, mxRecord);
							}
						}

						// printf("dd The next query ipAddr: %s\n", serverRecord->rdata);
					}
					else if (serverHead->tag == 33155)
					{ // 8183
						printf("Not found!\n");
						serverRecord->type = serverQuery->qtype;
						serverHead->id = htons(serverHead->id);
						serverHead->tag = htons(serverHead->tag);
						serverHead->queryNum = htons(serverHead->queryNum);
						serverHead->answerNum = htons(serverHead->answerNum);
						serverHead->authorNum = 0;
						serverHead->addNum = 0;
						char *p2 = bufOut + 2;
						p2 += head2buf(p2, serverHead);
						p2 += query2buf(p2, serverQuery);
						// p2 += rr2buf(p2,serverRecord);
						uint16_t offset = p2 - bufOut - 2;
						uint16_t temp = htons(offset);
						memcpy(bufOut, &temp, sizeof(short));
						sed = send(confd, bufOut, offset + 2, 0);
						if (sed < 0)
						{
							perror("send failed");
							close(serfd);
							return -1;
						}
						printf("Send to Client Success\n");
						break;
					}
					else if (serverHead->tag == 33152)
					{ // 8180
						printf("Found successful!");
						serverRecord->type = serverQuery->qtype;
						serverHead->id = htons(serverHead->id);
						serverHead->tag = htons(serverHead->tag);
						serverHead->queryNum = htons(serverHead->queryNum);
						serverHead->answerNum = htons(serverHead->answerNum);
						serverHead->authorNum = 0;
						serverHead->addNum = 0;
						if (serverQuery->qtype == MX_TYPE)
						{
							serverHead->addNum = htons(1);
						}
						char *p2 = bufOut + 2;
						p2 += head2buf(p2, serverHead);
						p2 += query2buf(p2, serverQuery);
						p2 += rr2buf(p2, serverRecord);
						if (serverQuery->qtype == MX_TYPE)
							p2 += add2buf(p2, mxRecord, serverQuery);
						uint16_t offset = p2 - bufOut - 2;
						uint16_t temp = htons(offset);
						memcpy(bufOut, &temp, sizeof(short));
						sed = send(confd, bufOut, offset + 2, 0);
						if (sed < 0)
						{
							perror("send failed");
							close(serfd);
							return -1;
						}
						printf("Send to Client Success\n");
						break;
					}
				}

				// printf("Recieved : %s\n", bufFromRoot);
				close(sockudp);
				// break;
			}
			else
			{
				/*
				 *压缩返回
				 */
				printf("Find in local server cache.\n");
				o = bufOut + 2;
				o += head2buf(o, resHead);
				o += query2buf(o, resQuery);
				o += rr2buf(o, resRecord);

				if (recvQuery->qtype == MX_TYPE)
					o += add2buf(o, mxRecord, recvQuery);

				offset = o - bufOut - 2;
				offsetptr = &offset;
				uint16_t temp = htons(offset);
				memcpy(bufOut, &temp, sizeof(short)); // 将DNS包长度写在前两字节

				sed = send(confd, bufOut, offset + 2, 0);
				if (sed < 0)
				{
					perror("send failed");
					close(serfd);
					return -1;
				}
				printf("Send Success\n");
			}
		}

		/*
		 *发送回去
		 */
		// int outlen = 0;
		// for(bfrlen = 0; ; bfrlen++){
		// 	if(bufFromRoot[bfrlen] == '\0') break;
		// }
	}

	close(confd);
	close(serfd);

	return 0;
}

unsigned int rr2buf(char *o, dns_rr *rr)
{
	int i = 0;
	uint16_t temp;
	uint32_t temp32;
	temp = htons(49164); // 这里指代1100000000001100，DNS报文中压缩指针的操作
	memcpy(o, &temp, sizeof(short));

	//	printf("rr2leng: %d\n", strlen(rr->name));
	//	memcpy(o,rr->name,strlen(rr->name)+1);
	//	while(1){
	//		printf("ccc: %c\n", o[i]);
	//		i++;
	//		if(i == 5) break;
	//	}
	//	printf("rrName: %s\n", o);
	o += 2;
	// printf("flag3\n");
	temp = htons(rr->type);
	memcpy(o, &temp, sizeof(short));
	// printf("rrType: %d\n", rr->type);
	o += 2;
	// printf("flag3\n");
	temp = htons(rr->rclass);
	memcpy(o, &temp, sizeof(short));
	o += 2;
	// printf("flag3\n");
	temp32 = htonl(rr->ttl); // 这里是htonl 32位数字的主机字节序转化
	// printf("ttlconvert: %d\n", temp32);
	memcpy(o, &temp32, (2 * sizeof(short)));
	o += 4;
	// printf("flag3\n");
	temp = htons(rr->data_len);
	memcpy(o, &temp, sizeof(short));
	o += 2;
	// printf("flag3\n");
	// 这里指preference，MX里面要多两个字节哦
	if (rr->type == MX_TYPE)
	{
		temp = htons(1);
		memcpy(o, &temp, sizeof(short));
		o += 2;
	}

	if (rr->type == A_TYPE)
	{
		uint32_t ipAddr = inet_addr(rr->rdata);
		memcpy(o, &ipAddr, rr->data_len); // 将字符串转化为网络字节序的4bytes数据
		// printf("rrDate: %s\n", o);
		o += rr->data_len; // 也就是要移动4位
		return 16;
	}
	else if (rr->type == CNAME_TYPE)
	{
		char *ini = o; // for initial
		uint8_t count = 0;
		int i = 0;
		int j = 1; // 转换后计数
		int tempts = 0;
		o++; // 先往后移动一位
		while (1)
		{
			// printf("get: %c\n", rr->rdata[i]);
			if (rr->rdata[i] == '.')
			{
				memcpy(o - count - 1, &count, sizeof(char));
				// printf("Count: %d\n", count);
				count = 0;
				o++;
				i++;
				tempts = 1;
			}
			else if (rr->rdata[i] == '\0')
			{
				memcpy(o, &(rr->rdata[i]), sizeof(char));
				memcpy(o - count - 1, &count, sizeof(char));
				count = 0;
				break;
			}
			else
			{
				memcpy(o, &(rr->rdata[i]), sizeof(char));
				o++;
				i++;
				count++;
			}
		}
		return 12 + rr->data_len + 1;
	}
	else if (rr->type == MX_TYPE)
	{				   // MX的情况
		char *ini = o; // for initial
		uint8_t count = 0;
		int i = 0;
		int j = 1; // 转换后计数
		int tempts = 0;
		o++; // 先往后移动一位
		while (1)
		{
			// printf("get: %c\n", rr->rdata[i]);
			if (rr->rdata[i] == '.')
			{
				memcpy(o - count - 1, &count, sizeof(char));
				//("Count: %d\n", count);
				count = 0;
				o++;
				i++;
				tempts = 1;
				break;
			}
			else if (rr->rdata[i] == '\0')
			{
				memcpy(o, &(rr->rdata[i]), sizeof(char));
				memcpy(o - count - 1, &count, sizeof(char));
				count = 0;
				break;
			}
			else
			{
				memcpy(o, &(rr->rdata[i]), sizeof(char));
				o++;
				i++;
				count++;
			}
		}
		o--;
		// printf("i=%d\n", i);
		temp = htons(49164); // 这里指代1100000000001100，DNS报文中压缩指针的操作
		memcpy(o, &temp, sizeof(short));
		return 16 + i;
	}
}
unsigned int head2buf(char *o, dns_header *head)
{
	memcpy(o, head, sizeof(dns_header));
	return sizeof(dns_header);
}

unsigned int query2buf(char *o, dns_query *query)
{
	char *ini = o; // for initial
	uint8_t count = 0;
	int i = 0;
	int j = 1; // 转换后计数
	int tempts = 0;
	o++; // 先往后移动一位
	while (1)
	{
		//("get: %c\n", query->name[i]);
		if (query->name[i] == '.')
		{
			memcpy(o - count - 1, &count, sizeof(char));
			//("Count: %d\n", count);
			count = 0;
			o++;
			i++;
			tempts = 1;
		}
		else if (query->name[i] == '\0')
		{
			memcpy(o, &(query->name[i]), sizeof(char));
			memcpy(o - count - 1, &count, sizeof(char));
			count = 0;
			break;
		}
		else
		{
			memcpy(o, &(query->name[i]), sizeof(char));
			o++;
			i++;
			count++;
		}
	}
	o++;
	int len = o - ini; // 计算出名字的长度
	// printf("length: %d\n", len);
	uint16_t temp = htons(query->qtype);
	memcpy(o, &temp, sizeof(short));
	temp = htons(query->qclass);
	o += sizeof(short);
	memcpy(o, &temp, sizeof(short));
	o += sizeof(short);
	//	int p=0;
	//	while(p<=100){
	//	printf("buff1: %hu\n", o[p]);
	//	p++;
	//	}
	// printf("length22: %d\n",  len+2*sizeof(short));
	return len + 2 * sizeof(short);
}
unsigned int getHeader(char *q, dns_header *header)
{
	// int i = 0;
	// while(1){
	// 	if(i<100){
	// 		printf("headerIn: %d\n", q[i]);i++;
	// 	}

	// 	else break;
	// }

	header->id = ntohs(*(uint16_t *)(q));
	header->tag = ntohs(*(uint16_t *)(q + 2));
	header->queryNum = ntohs(*(uint16_t *)(q + 4));
	// printf("queryName: %d\n", header->id);
	header->answerNum = ntohs(*(uint16_t *)(q + 6));
	header->authorNum = ntohs(*(uint16_t *)(q + 8));
	header->addNum = ntohs(*(uint16_t *)(q + 10));

	return sizeof(dns_header);
}

unsigned int getQuery(char *q, dns_query *query)
{
	char domainName[100];
	memset(domainName, 0, 100);
	char *d = domainName;
	// printf("d: %s\n", d);
	uint8_t count = 0;
	int i = 0;

	// count = ntohs(*(uint8_t*)(q));
	// 完成报文中数字加域名形式至点分值的转换
	while (1)
	{
		if (*q != '\0')
		{
			count = *(uint8_t *)(q);
			// printf("count:%d\n", count);
			q++;
			while (count)
			{
				// printf("i: %d\n", i);
				// printf("char1:%c\n", *q);
				memcpy(&(domainName[i]), q, sizeof(char));
				// printf("domain name i: %c\n", domainName[i]);
				count--;
				q++;
				i++;
			}
			domainName[i] = '.'; // 加点
			i++;
		}
		else
		{
			domainName[i - 1] = '\0'; // 标注结束
			q++;
			break;
		}
	}
	// printf("i: %d\n", i);
	// printf("Converted domain name: %s\n", domainName);
	// printf("length: %d\n", i);
	query->name = (char *)malloc(i * sizeof(char));
	memcpy(query->name, domainName, i); // 此时的i便为变长字符串的长度了，经过了循环遍历
	// printf("Query name: %s\n", query->name);

	query->qtype = ntohs(*(uint16_t *)(q));
	query->qclass = ntohs(*(uint16_t *)(q + 2));
	// printf("Query Type: %d\n", query->qtype);
	// printf("Query Class: %d\n", query->qclass);
	return i + 4 + 1; // 网络形式的域名表示和点分值差1，在这里特地补上
}

unsigned int compare(dns_query *query, char *col)
{
	unsigned int offset = 0;
	// printf("in cmp\n");
	if (offset = cmpDomainName(query->name, col))
	{
		// printf("in if 1\n");
		if (cmpTypeClass(query->qtype, col + offset))
			return 1;
	}
	return 0;
}
unsigned int cmpTypeClass(unsigned short type, char *col)
{
	return 1;
}
unsigned int cmpDomainName(char *name, char *col)
{
	int len = strlen(name), i = 0;
	//	printf("%d\n",len);
	while (i < len)
	{
		//		printf("namei: %c\n",name[i]);
		//		printf("coli: %c\n",col[i]);
		if (name[i] != col[i])
		{
			return 0;
		}
		i++;
	}
	if (col[i] != ' ')
		return 0;
	else
		return len + 1;
}

int blocklen(char *cur)
{
	int i = 0;
	while (1)
	{
		if (cur[i] == ' ' || cur[i] == '\n' || cur[i] == '\0')
			break;
		else
			i++;
	}
	return i + 1;
}

void init_DNS_RR(dns_query *recvQuery, dns_rr *resRecord, char *col)
{
	char *cur = col; // 光标
	unsigned int len = 0;
	// printf("in DNS\n");

	/*
	 *拷贝可从query里获取的信息
	 */
	//	resRecord->name = (char*)malloc(strlen(recvQuery->name)*sizeof(char));
	resRecord->name = recvQuery->name;
	resRecord->rclass = recvQuery->qclass;
	resRecord->type = recvQuery->qtype;

	/*
	 *拷贝ttl
	 */
	len = blocklen(cur);
	cur += len; // name
	// printf("name_length: %d\n",len);

	len = blocklen(cur); // ttl字符串长度
	// printf("ttl_char_length:%d\n",len);

	char strttl[len];
	memcpy(strttl, cur, len - 1);
	strttl[len - 1] = '\0';
	cur += len;
	int TTL = atoi(strttl); // printf("TTL；%d\n",TTL); //转换后TTL
	resRecord->ttl = (uint32_t)TTL;
	// printf("ttl: %d\n",resRecord->ttl);
	/*
	 *移动光标
	 */
	len = blocklen(cur);
	cur += len; // type
	// printf("cur length:%d\n",len);
	len = blocklen(cur);
	cur += len; // class
	// printf("len length:%d\n",len);
	/*
	 *拷贝 rdata
	 */
	len = blocklen(cur);
	// printf("rdata: %d\n",len);
	char strData[len];
	memcpy(strData, cur, len - 1);
	strData[len - 2] = '\0';
	char *strPointer = strData;
	resRecord->rdata = (char *)malloc((len - 1) * sizeof(char));
	memcpy(resRecord->rdata, strPointer, len - 1);
	// printf("size: %d\n",strlen(resRecord->rdata));
	// printf("rdata: %s\n",resRecord->rdata);

	/*
	 *拷贝datalength
	 */
	if (resRecord->type == A_TYPE)
	{
		resRecord->data_len = 4; // 永远是4byte
	}
	else if (resRecord->type == CNAME_TYPE)
	{
		resRecord->data_len = strlen(resRecord->rdata) + 1;
	}
	else if (resRecord->type == MX_TYPE)
	{
		// 这里用现在的域名减去查询的名字长度再+2(pre..)+2(压缩指针)
		resRecord->data_len = strlen(resRecord->rdata) - strlen(recvQuery->name) + 4;
	}

	// printf("%hu\n",len-1);
}
void init_sockaddr_in(char *ip, int port, struct sockaddr_in *addr)
{
	addr->sin_family = AF_INET;
	addr->sin_port = htons(port);
	addr->sin_addr.s_addr = inet_addr(ip);
	memset(addr->sin_zero, 0, sizeof(addr->sin_zero));
}

unsigned int getRRs(char *q, dns_rr *rRecord)
{
	uint32_t ipAddr;
	rRecord->ttl = ntohl(*(uint32_t *)(q)); // 这里是ntohl，32bit数字的转化
	char str[INET_ADDRSTRLEN];
	struct in_addr addr;
	// printf("Query Answer TTL: %d\n", rRecord->ttl);
	q += sizeof(rRecord->ttl);
	rRecord->data_len = ntohs(*(uint16_t *)(q));
	// printf("Data Length: %d\n", rRecord->data_len);
	q += sizeof(rRecord->data_len);
	// rRecord->rdata = (char*)malloc((rRecord->data_len)*sizeof(char));
	// printf("hello\n");
	if (rRecord->type == MX_TYPE)
	{
		q += 2; // 将Preferencre的长度空出去
	}

	if (rRecord->type == A_TYPE)
	{
		ipAddr = *(uint32_t *)(q);
		// printf("Query Answer TTL: %d\n", rRecord->ttl);
		memcpy(&addr, &ipAddr, 4);
		char *ptr = inet_ntop(AF_INET, &addr, str, sizeof(str)); // 转化为十进制点分值的IP地址
		// printf("Query Answer IP: %s\n", ptr);
		rRecord->rdata = (char *)malloc((strlen(ptr) + 1) * sizeof(char));
		strcpy(rRecord->rdata, ptr);
		return 4 + 2 + rRecord->data_len;
	}
	else if (rRecord->type == CNAME_TYPE)
	{
		char domainName[100];
		memset(domainName, 0, 100);
		char *d = domainName;
		//("d: %s\n", d);
		uint8_t count = 0;
		int i = 0;
		// count = ntohs(*(uint8_t*)(q));
		// 完成报文中数字加域名形式至点分值的转换
		while (1)
		{
			if (*q != '\0')
			{
				count = *(uint8_t *)(q);
				// printf("count:%d\n", count);
				q++;
				while (count)
				{
					// printf("i: %d\n", i);
					// printf("char1:%c\n", *q);
					memcpy(&(domainName[i]), q, sizeof(char));
					// printf("domain name i: %c\n", domainName[i]);
					count--;
					q++;
					i++;
				}
				domainName[i] = '.'; // 加点
				i++;
			}
			else
			{
				domainName[i - 1] = '\0'; // 标注结束
				q++;
				break;
			}
		}
		// printf("i: %d\n", i);
		// printf("Converted domain name: %s\n", domainName);
		// printf("length: %d\n", i);
		rRecord->rdata = (char *)malloc(i * sizeof(char));
		memcpy(rRecord->rdata, domainName, i); // 此时的i便为转换后变长字符串的长度了，经过了循环遍历
		// printf("Query name: %s\n", rRecord->rdata);
		// 	printf("The CNAME is: %s\n", rRecord->rdata);
		return 4 + 2 + rRecord->data_len + 1;
	}
	else if (rRecord->type == MX_TYPE)
	{
		int firstlen = rRecord->data_len - 5;
		char domainName[100];
		memset(domainName, 0, 100);
		char *d = domainName;
		// printf("d: %s\n", d);
		uint8_t count = 0;
		int i = 0;
		// count = ntohs(*(uint8_t*)(q));
		// 完成报文中数字加域名形式至点分值的转换
		while (1)
		{
			if (*q != '\0')
			{
				count = *(uint8_t *)(q);
				// printf("count:%d\n", count);
				q++;
				while (count)
				{
					// printf("i: %d\n", i);
					// printf("char1:%c\n", *q);
					memcpy(&(domainName[i]), q, sizeof(char));
					// printf("domain name i: %c\n", domainName[i]);
					count--;
					q++;
					i++;
				}
				domainName[i] = '.'; // 加点
				i++;
				domainName[i] = '\0';
				i++;
				break;
			}
		}
		// printf("i: %d\n", i);
		// printf("Converted domain name: %s\n", domainName);
		// printf("length: %d\n", i);
		strcpy(domainName, strcat(domainName, rRecord->name)); // 由于压缩了指针，对两字符串进行拼接
		// printf("Converted domain name: %s\n", domainName);
		int totalen = strlen(rRecord->name) + i; // 拼接后总长度
		rRecord->rdata = (char *)malloc(totalen * sizeof(char));
		memcpy(rRecord->rdata, domainName, totalen);
		// printf("Query name: %s\n", rRecord->rdata);
		// printf("The CNAME is: %s\n", rRecord->rdata);
		return 12 + rRecord->data_len;
	}
}
// 用于MX的ip查询，放到addtion里面
unsigned int add2buf(char *o, dns_rr *rr, dns_query *query)
{
	// printf("add2buf rrdata: %s\n", rr->rdata);
	// printf("datalength: %d\n", strlen(rr->rdata));
	int i = 0;
	uint16_t temp;
	uint32_t temp32;
	temp = htons(49152 + 12 + strlen(query->name) + 2 + 4 + 14); // 这里指代1100000000001100，DNS报文中压缩指针的操作
	memcpy(o, &temp, sizeof(short));
	//	printf("rr2leng: %d\n", strlen(rr->name));
	//	memcpy(o,rr->name,strlen(rr->name)+1);
	//	while(1){
	//		printf("ccc: %c\n", o[i]);
	//		i++;
	//		if(i == 5) break;
	//	}
	//	printf("rrName: %s\n", o);
	o += 2;
	temp = htons(rr->type);
	memcpy(o, &temp, sizeof(short));
	// printf("rrType: %d\n", rr->type);
	o += 2;

	temp = htons(rr->rclass);
	memcpy(o, &temp, sizeof(short));
	o += 2;

	temp32 = htonl(rr->ttl); // 这里是htonl 32位数字的主机字节序转化
	// printf("ttlconvert: %d\n", temp32);
	memcpy(o, &temp32, (2 * sizeof(short)));
	o += 4;

	temp = htons(rr->data_len);
	memcpy(o, &temp, sizeof(short));
	o += 2;

	uint32_t ipAddr = inet_addr(rr->rdata);
	memcpy(o, &ipAddr, rr->data_len); // 将字符串转化为网络字节序的4bytes数据
	// printf("rrDate: %d\n", ipAddr);
	o += rr->data_len; // 也就是要移动4位
	return 16;
}

Makefile文件如下：
CC = gcc
CFLAGS = -Wall

SRCS = client.c cnus.c comorg.c edu.c gov.c localServer.c root.c
EXECS = $(SRCS:.c=)

# 默认的目标，编译生成所有可执行程序
all: $(EXECS)

# 生成每个可执行程序
%: %.c
	$(CC) $(CFLAGS) $< -o $@

# 清除生成的可执行程序
clean:
	rm -f $(EXECS)

root.c文件如下：
#include<stdio.h>
#include<sys/types.h>
#include<string.h>
#include<unistd.h>
#include<netinet/in.h>
#include<sys/socket.h>
#include<unistd.h>
#include<stdlib.h>
#include<netinet/in.h>
#include<arpa/inet.h>
#include<stdint.h>
#include "DNS.h"
#define LINE     10
#define DNS_MAX_LENGTH 1023

int isequal(char *str1, char* str2);
void init_sockaddr_in(char* ip, int port, struct sockaddr_in* addr);
unsigned int getHeader(char *q, dns_header *header);
unsigned int getQuery(char *q, dns_query *query);
void splitOneDomainName(char *domainName, char *splitName);
unsigned int head2buf(char *o, dns_header *header);
unsigned int query2buf(char *o, dns_query *query);
unsigned int getRRs(char *q, dns_rr *rRecord);
unsigned int rr2buf(char *o, dns_rr* rr); 

int main(){
	int sockup;
	struct sockaddr_in localAddr;
	struct sockaddr_in upAddr;
	unsigned int upAddrLen;
	char upInBuffer[DNS_MAX_LENGTH];
	char upOutBuffer[DNS_MAX_LENGTH];
	char splitName[100];
	char ipAddr[100];
	dns_query *recvQuery = (dns_query *)malloc(sizeof(dns_query));initQuery(recvQuery);
	dns_header *recvHead = (dns_header *)malloc(sizeof(dns_header));initHead(recvHead);
	//回应的结构体 
	dns_query *resQuery = (dns_query *)malloc(sizeof(dns_query));initQuery(resQuery);
	dns_header *resHead = (dns_header *)malloc(sizeof(dns_header));initHead(resHead);
	dns_rr *resRecord = (dns_rr *)malloc(sizeof(dns_rr));initRR(resRecord);
	unsigned short port=53;
	int recvMsgSize;
	int outMsgSize; 
	char *i;
	char *o;
	
	if((sockup=socket(PF_INET,SOCK_DGRAM,0))<0)  printf("socket() failed\n");
	
	init_sockaddr_in("127.0.0.3", 53, &localAddr);
	if((bind (sockup,(struct sockaddr*)&localAddr,sizeof(localAddr)))<0){
		printf("bind() failed\n");
	} 
	while(1){
	upAddrLen=sizeof(upAddr);
	//receive
	if((recvMsgSize=recvfrom(sockup,upInBuffer,DNS_MAX_LENGTH,0,(struct sockaddr*)&upAddr,&upAddrLen))<0){
		printf("recvfrom() failed\n");
	}
	printf("Handling client %s\n",inet_ntoa(upAddr.sin_addr));
	
	
	//解析localServer传过来的数据 
	i = upInBuffer;
	i += getHeader(i, recvHead);
	i += getQuery(i, recvQuery); 	
	printf("The domain name is: %s\n", recvQuery->name);
	//printf("The First Class Name is: %s\n", splitOneDomainName(recvQuery->name));
	splitOneDomainName(recvQuery->name, splitName);
	
	//解析部分至上就结束了，以下为回应部分
	resHead->id =htons(recvHead->id);
	resHead->tag =htons(0x8000);
	resHead->queryNum =htons(recvHead->queryNum);
	resHead->answerNum = htons(1); //这里不一定是1，若没查到怎么办？？ 
	resHead->authorNum = 0;
	resHead->addNum = 0;
	resQuery = recvQuery;
	resRecord->name=recvQuery->name;
    resRecord->rclass=recvQuery->qclass;
	resRecord->type=A_TYPE;
	resRecord->ttl = (uint32_t)86400;
	resRecord->data_len = 4;
	
	//printf("compare:  %s\n",splitName);
    int tf=isequal(splitName,"com");
    //printf("bbbbbb: %d\n",tf);
    tf=isequal(splitName,"org");
    //printf("basafds: %d\n",tf);
	/*
	 *返回一级域ip 
	 */
	if(isequal(splitName,"com")||isequal(splitName,"org")){
	    //在结构体里把rdata赋值为ip（127.0.0.4） ,在head里把anwernum赋值为0 
	    //printf("hello, in org!\n");
	    strcpy(ipAddr, "127.0.0.4");
	   // printf("hello,%s\n", ipAddr);
	    char *p = ipAddr;
	    int len = strlen(ipAddr)+1;
	    resRecord->rdata=(char*)malloc(len*sizeof(char));
	    //printf("hello, in org!\n");
	    memcpy(resRecord->rdata,p,len);
	    //printf("resRecordDataL %s\n", resRecord->rdata);
	   // printf("hello, in org!\n");
	    //strcpy(resRecord->rdata, "127.0.0.4");
		o = upOutBuffer; 
	 	o += head2buf(o, resHead);
	 	o += query2buf(o,resQuery); 
		o += rr2buf(o,resRecord);
	    
	    
	}
	else if(isequal(splitName,"cn")||isequal(splitName,"us")){
		 //在结构体里把rdata赋值为ip（127.0.0.5）,在head里把anwernum赋值为0
		strcpy(ipAddr, "127.0.0.5");
		char *p = ipAddr;
	    int len = strlen(ipAddr)+1;
	    resRecord->rdata=(char*)malloc(len*sizeof(char));
	    //printf("hello, in org!\n");
	    memcpy(resRecord->rdata,p,len);
	    //printf("resRecordDataL %s\n", resRecord->rdata);
		o = upOutBuffer; 
	 	o += head2buf(o, resHead);
	 	o += query2buf(o,resQuery); 
		o += rr2buf(o,resRecord);
	 	//int p = 0;
	 	// while(1){
	 	// printf("%hu\n", upOutBuffer[p]);
	 	// p++;
	 	// if(p>100) break;
	 	// }
	 	// printf("\n");
	} 
	else{
		resHead->answerNum = 0;
		resHead->tag =htons(0x8183);
		o = upOutBuffer; 
	 	o += head2buf(o, resHead);
	 	o += query2buf(o,resQuery); 
		//rdata无数值，anwernum为0
		//查询失败 
	} 
	 
	

	
	
	
	//send
	//strcpy(upOutBuffer,"DASHABI");
	outMsgSize=o - upOutBuffer +1;
	//printf("length:%d \n",outMsgSize);
	if(sendto(sockup,upOutBuffer,outMsgSize,0,(struct sockaddr*)&upAddr,sizeof(upAddr))!=outMsgSize){
		printf("sendto() problem!\n");
	}
	
	}	
}
 int isequal(char *str1, char* str2)
{
    if (strlen(str1)!=strlen(str2))
     return 0;
     int i=0;
    for (i = 0; str1[i]!='\0'; i++){
        if (str1[i]!=str2[i])
        return 0;
     }
   return 1;
  }

void init_sockaddr_in(char* ip, int port, struct sockaddr_in* addr){
    addr->sin_family = AF_INET;
    addr->sin_port = htons(port);
    addr->sin_addr.s_addr=inet_addr(ip);
    memset(addr->sin_zero, 0, sizeof(addr->sin_zero));
}

unsigned int getHeader(char *q, dns_header *header){
	// int i = 0;
	// while(1){
	// 	if(i<100){
	// 		printf("headerIn: %d\n", q[i]);i++;
	// 	}
		
	// 	else break;
	// }
	
	header->id = ntohs(*(uint16_t*) (q));
	header->tag = ntohs(*(uint16_t*) (q+2));
	header->queryNum = ntohs(*(uint16_t*) (q+4));
	//printf("queryName: %d\n", header->id);
	header->answerNum = ntohs(*(uint16_t*) (q+6));
	header->authorNum = ntohs(*(uint16_t*) (q+8));
	header->addNum = ntohs(*(uint16_t*) (q+10));
	
	return sizeof(dns_header);
}

unsigned int getQuery(char *q, dns_query *query){
	char domainName[100];
	memset(domainName, 0, 100);
	char *d = domainName;
	//printf("d: %s\n", d);
	uint8_t count = 0;
	int i = 0; 
	//count = ntohs(*(uint8_t*)(q));
	//完成报文中数字加域名形式至点分值的转换 
	while(1){
		if(*q!='\0'){
			count = *(uint8_t*)(q);
			//("count:%d\n", count);
			q++;
			while(count){
				//printf("i: %d\n", i);
				//printf("char1:%c\n", *q);
				memcpy(&(domainName[i]), q, sizeof(char));
				//printf("domain name i: %c\n", domainName[i]);
				count--; q++; i++;
			}
			domainName[i] = '.'; //加点 
			i++;
		}
		else{
			domainName[i-1] = '\0'; //标注结束 
			q++; 
			break;
		}
	}
	// printf("i: %d\n", i);  
	// printf("Converted domain name: %s\n", domainName);
	// printf("length: %d\n", i);
	query->name = (char*)malloc(i*sizeof(char));
	memcpy(query->name, domainName, i); //此时的i便为转换后变长字符串的长度了，经过了循环遍历 
	//printf("Query name: %s\n", query->name);
	
	query->qtype = ntohs(*(uint16_t*) (q));
	query->qclass = ntohs(*(uint16_t*) (q+2));
	//printf("Query Type: %d\n", query->qtype);
	//printf("Query Class: %d\n", query->qclass);
	return i+4+1; //补一个1的原因是网络的域名形式和转换后的差一位 
}

void splitOneDomainName(char *domainName, char *splitName){
	int i = strlen(domainName)-1; //免去\0的影响 
	//printf("domainName: %s\n", domainName);
	int j = 0;
	int k = 0;
	char invertName[100];
	char splitOneName[100];
	memset(invertName, 0, 100);
	memset(splitOneName, 0, 100);
	while(1){
		if(domainName[i]!='.'){
			//printf("d: %c\n", domainName[i]);
			invertName[j] = domainName[i];
			//printf("s: %c\n", invertName[j]);
			i--;j++; 
		}else break;
	}
	invertName[j] = '\0';
	//printf("splitOneInvert: %s\n", invertName);
	i = strlen(invertName)-1;
	while(1){
		if(k < strlen(invertName)){
			////printf("s: %c\n", invertName[i]);
			splitName[k] = invertName[i];
			i--; k++;
		}else break;
		
	}
	splitName[k] = '\0';
	
	//printf("splitOne: %s\n", splitName);
}

unsigned int head2buf(char *o, dns_header *head){
	memcpy(o, head, sizeof(dns_header));

	return sizeof(dns_header);
}

unsigned int query2buf(char *o, dns_query *query){
	char* ini = o; //for initial
	uint8_t count = 0;
	int i = 0;
	int j = 1; //转换后计数 
	int tempts = 0;
	o++; //先往后移动一位 
	while(1){
		//printf("get: %c\n", query->name[i]);
		if(query->name[i] == '.'){
				memcpy(o-count-1, &count, sizeof(char));
				//printf("Count: %d\n", count);
				count = 0;
				o++; i++;
				tempts = 1;
				
		}
		else if(query->name[i] == '\0'){
			memcpy(o, &(query->name[i]), sizeof(char));
			memcpy(o-count-1, &count, sizeof(char));
			count = 0;
			break;
		}
		else{
			memcpy(o, &(query->name[i]), sizeof(char));
			o++;
			i++;
			count++; 
		}
	}
	o++;
	int len = o - ini; //计算出名字的长度
	//printf("length: %d\n", len); 
	uint16_t temp = htons(query->qtype);
	memcpy(o, &temp, sizeof(short));
	temp = htons(query->qclass);
	o+=sizeof(short);
	memcpy(o, &temp, sizeof(short));
	o+=sizeof(short);
//	int p=0;
//	while(p<=100){
//	printf("buff1: %hu\n", o[p]);
//	p++;
//	}
	//printf("length22: %d\n",  len+2*sizeof(short)); 
	return len+2*sizeof(short);
}

unsigned int rr2buf(char *o, dns_rr* rr) {
	int i = 0;
	uint16_t temp;
	uint32_t temp32;
	temp =  htons(49164); //这里指代1100000000001100，DNS报文中压缩指针的操作
	memcpy(o, &temp, sizeof(short)); 
//	printf("rr2leng: %d\n", strlen(rr->name));
//	memcpy(o,rr->name,strlen(rr->name)+1);
//	while(1){
//		printf("ccc: %c\n", o[i]);
//		i++;
//		if(i == 5) break;
//	}
//	printf("rrName: %s\n", o);
	o+=2;
	
	temp=htons(rr->type);
	memcpy(o, &temp, sizeof(short));
	//printf("rrType: %d\n", rr->type);
	o+=2;
	
	temp=htons(rr->rclass);
	memcpy(o, &temp, sizeof(short));
	o+=2;
	
	temp32=htonl(rr->ttl); //这里是htonl 32位数字的主机字节序转化 
	//printf("ttlconvert: %d\n", temp32);
	memcpy(o, &temp32, (2*sizeof(short)));
	o+=4;
	
	temp=htons(rr->data_len);
	memcpy(o, &temp, sizeof(short));
	o+=2;
	
	uint32_t  ipAddr = inet_addr(rr->rdata);
	memcpy(o, &ipAddr,rr->data_len); //将字符串转化为网络字节序的4bytes数据 
	//printf("rrDate: %s\n", o);
	o+=rr->data_len; //也就是要移动4位 
	return 11+strlen(rr->name)+(rr->data_len);
}

